{
  "url": "https://en.wikipedia.org/wiki/Inductive_programming",
  "title": "Inductive programming",
  "html": "<!DOCTYPE html>\n<html class=\"client-nojs\" dir=\"ltr\" lang=\"en\">\n<head>\n<meta charset=\"utf-8\"/>\n<title>Inductive programming - Wikipedia</title>\n<script>document.documentElement.className = document.documentElement.className.replace( /(^|\\s)client-nojs(\\s|$)/, \"$1client-js$2\" );</script>\n<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({\"wgCanonicalNamespace\":\"\",\"wgCanonicalSpecialPageName\":false,\"wgNamespaceNumber\":0,\"wgPageName\":\"Inductive_programming\",\"wgTitle\":\"Inductive programming\",\"wgCurRevisionId\":884213955,\"wgRevisionId\":884213955,\"wgArticleId\":41644056,\"wgIsArticle\":true,\"wgIsRedirect\":false,\"wgAction\":\"view\",\"wgUserName\":null,\"wgUserGroups\":[\"*\"],\"wgCategories\":[\"CS1: long volume value\",\"Programming paradigms\",\"Machine learning\",\"Logic programming\",\"Artificial intelligence\"],\"wgBreakFrames\":false,\"wgPageContentLanguage\":\"en\",\"wgPageContentModel\":\"wikitext\",\"wgSeparatorTransformTable\":[\"\",\"\"],\"wgDigitTransformTable\":[\"\",\"\"],\"wgDefaultDateFormat\":\"dmy\",\"wgMonthNames\":[\"\",\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"],\"wgMonthNamesShort\":[\"\",\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"],\"wgRelevantPageName\":\"Inductive_programming\",\"wgRelevantArticleId\":41644056,\"wgRequestId\":\"XG8TbApAICoAACvnUHUAAAAV\",\"wgCSPNonce\":false,\"wgIsProbablyEditable\":true,\"wgRelevantPageIsProbablyEditable\":true,\"wgRestrictionEdit\":[],\"wgRestrictionMove\":[],\"wgFlaggedRevsParams\":{\"tags\":{}},\"wgStableRevisionId\":null,\"wgCategoryTreePageCategoryOptions\":\"{\\\"mode\\\":0,\\\"hideprefix\\\":20,\\\"showcount\\\":true,\\\"namespaces\\\":false}\",\"wgWikiEditorEnabledModules\":[],\"wgBetaFeaturesFeatures\":[],\"wgMediaViewerOnClick\":true,\"wgMediaViewerEnabledByDefault\":true,\"wgPopupsShouldSendModuleToUser\":true,\"wgPopupsConflictsWithNavPopupGadget\":false,\"wgVisualEditor\":{\"pageLanguageCode\":\"en\",\"pageLanguageDir\":\"ltr\",\"pageVariantFallbacks\":\"en\",\"usePageImages\":true,\"usePageDescriptions\":true},\"wgMFIsPageContentModelEditable\":true,\"wgMFEnableFontChanger\":true,\"wgMFDisplayWikibaseDescriptions\":{\"search\":true,\"nearby\":true,\"watchlist\":true,\"tagline\":false},\"wgRelatedArticles\":null,\"wgRelatedArticlesUseCirrusSearch\":true,\"wgRelatedArticlesOnlyUseCirrusSearch\":false,\"wgWMESchemaEditAttemptStepOversample\":false,\"wgPoweredByHHVM\":true,\"wgULSCurrentAutonym\":\"English\",\"wgNoticeProject\":\"wikipedia\",\"wgCentralNoticeCookiesToDelete\":[],\"wgCentralNoticeCategoriesUsingLegacy\":[\"Fundraising\",\"fundraising\"],\"wgWikibaseItemId\":\"Q15712089\",\"wgScoreNoteLanguages\":{\"arabic\":\"العربية\",\"catalan\":\"català\",\"deutsch\":\"Deutsch\",\"english\":\"English\",\"espanol\":\"español\",\"italiano\":\"italiano\",\"nederlands\":\"Nederlands\",\"norsk\":\"norsk\",\"portugues\":\"português\",\"suomi\":\"suomi\",\"svenska\":\"svenska\",\"vlaams\":\"West-Vlams\"},\"wgScoreDefaultNoteLanguage\":\"nederlands\",\"wgCentralAuthMobileDomain\":false,\"wgCodeMirrorEnabled\":true,\"wgVisualEditorToolbarScrollOffset\":0,\"wgVisualEditorUnsupportedEditParams\":[\"undo\",\"undoafter\",\"veswitched\"],\"wgEditSubmitButtonLabelPublish\":true,\"oresWikiId\":\"enwiki\",\"oresBaseUrl\":\"http://ores.discovery.wmnet:8081/\",\"oresApiVersion\":3});mw.loader.state({\"ext.gadget.charinsert-styles\":\"ready\",\"ext.globalCssJs.user.styles\":\"ready\",\"ext.globalCssJs.site.styles\":\"ready\",\"site.styles\":\"ready\",\"noscript\":\"ready\",\"user.styles\":\"ready\",\"ext.globalCssJs.user\":\"ready\",\"ext.globalCssJs.site\":\"ready\",\"user\":\"ready\",\"user.options\":\"ready\",\"user.tokens\":\"loading\",\"ext.cite.styles\":\"ready\",\"mediawiki.legacy.shared\":\"ready\",\"mediawiki.legacy.commonPrint\":\"ready\",\"mediawiki.toc.styles\":\"ready\",\"wikibase.client.init\":\"ready\",\"ext.visualEditor.desktopArticleTarget.noscript\":\"ready\",\"ext.uls.interlanguage\":\"ready\",\"ext.wikimediaBadges\":\"ready\",\"ext.3d.styles\":\"ready\",\"mediawiki.skinning.interface\":\"ready\",\"skins.vector.styles\":\"ready\"});mw.loader.implement(\"user.tokens@0tffind\",function($,jQuery,require,module){/*@nomin*/mw.user.tokens.set({\"editToken\":\"+\\\\\",\"patrolToken\":\"+\\\\\",\"watchToken\":\"+\\\\\",\"csrfToken\":\"+\\\\\"});\n});RLPAGEMODULES=[\"ext.cite.ux-enhancements\",\"site\",\"mediawiki.page.startup\",\"mediawiki.page.ready\",\"mediawiki.toc\",\"mediawiki.searchSuggest\",\"ext.gadget.teahouse\",\"ext.gadget.ReferenceTooltips\",\"ext.gadget.watchlist-notice\",\"ext.gadget.DRN-wizard\",\"ext.gadget.charinsert\",\"ext.gadget.refToolbar\",\"ext.gadget.extra-toolbar-buttons\",\"ext.gadget.switcher\",\"ext.centralauth.centralautologin\",\"ext.popups\",\"ext.visualEditor.desktopArticleTarget.init\",\"ext.visualEditor.targetLoader\",\"ext.eventLogging\",\"ext.wikimediaEvents\",\"ext.navigationTiming\",\"ext.uls.eventlogger\",\"ext.uls.init\",\"ext.uls.compactlinks\",\"ext.uls.interface\",\"ext.quicksurveys.init\",\"ext.centralNotice.geoIP\",\"ext.centralNotice.startUp\",\"skins.vector.js\"];mw.loader.load(RLPAGEMODULES);});</script>\n<link href=\"/w/load.php?debug=false&amp;lang=en&amp;modules=ext.3d.styles%7Cext.cite.styles%7Cext.uls.interlanguage%7Cext.visualEditor.desktopArticleTarget.noscript%7Cext.wikimediaBadges%7Cmediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.skinning.interface%7Cmediawiki.toc.styles%7Cskins.vector.styles%7Cwikibase.client.init&amp;only=styles&amp;skin=vector\" rel=\"stylesheet\"/>\n<script async=\"\" src=\"/w/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector\"></script>\n<meta content=\"\" name=\"ResourceLoaderDynamicStyles\"/>\n<link href=\"/w/load.php?debug=false&amp;lang=en&amp;modules=ext.gadget.charinsert-styles&amp;only=styles&amp;skin=vector\" rel=\"stylesheet\"/>\n<link href=\"/w/load.php?debug=false&amp;lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector\" rel=\"stylesheet\"/>\n<meta content=\"MediaWiki 1.33.0-wmf.18\" name=\"generator\"/>\n<meta content=\"origin\" name=\"referrer\"/>\n<meta content=\"origin-when-crossorigin\" name=\"referrer\"/>\n<meta content=\"origin-when-cross-origin\" name=\"referrer\"/>\n<link href=\"android-app://org.wikipedia/http/en.m.wikipedia.org/wiki/Inductive_programming\" rel=\"alternate\"/>\n<link href=\"/w/index.php?title=Inductive_programming&amp;action=edit\" rel=\"alternate\" title=\"Edit this page\" type=\"application/x-wiki\"/>\n<link href=\"/w/index.php?title=Inductive_programming&amp;action=edit\" rel=\"edit\" title=\"Edit this page\"/>\n<link href=\"/static/apple-touch/wikipedia.png\" rel=\"apple-touch-icon\"/>\n<link href=\"/static/favicon/wikipedia.ico\" rel=\"shortcut icon\"/>\n<link href=\"/w/opensearch_desc.php\" rel=\"search\" title=\"Wikipedia (en)\" type=\"application/opensearchdescription+xml\"/>\n<link href=\"//en.wikipedia.org/w/api.php?action=rsd\" rel=\"EditURI\" type=\"application/rsd+xml\"/>\n<link href=\"//creativecommons.org/licenses/by-sa/3.0/\" rel=\"license\"/>\n<link href=\"https://en.wikipedia.org/wiki/Inductive_programming\" rel=\"canonical\"/>\n<link href=\"//login.wikimedia.org\" rel=\"dns-prefetch\"/>\n<link href=\"//meta.wikimedia.org\" rel=\"dns-prefetch\"/>\n<!--[if lt IE 9]><script src=\"/w/load.php?debug=false&amp;lang=en&amp;modules=html5shiv&amp;only=scripts&amp;skin=vector&amp;sync=1\"></script><![endif]-->\n</head>\n<body class=\"mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject mw-editable page-Inductive_programming rootpage-Inductive_programming skin-vector action-view\"> <div class=\"noprint\" id=\"mw-page-base\"></div>\n<div class=\"noprint\" id=\"mw-head-base\"></div>\n<div class=\"mw-body\" id=\"content\" role=\"main\">\n<a id=\"top\"></a>\n<div class=\"mw-body-content\" id=\"siteNotice\"><!-- CentralNotice --></div><div class=\"mw-indicators mw-body-content\">\n</div>\n<h1 class=\"firstHeading\" id=\"firstHeading\" lang=\"en\">Inductive programming</h1> <div class=\"mw-body-content\" id=\"bodyContent\">\n<div class=\"noprint\" id=\"siteSub\">From Wikipedia, the free encyclopedia</div> <div id=\"contentSub\"></div>\n<div id=\"jump-to-nav\"></div> <a class=\"mw-jump-link\" href=\"#mw-head\">Jump to navigation</a>\n<a class=\"mw-jump-link\" href=\"#p-search\">Jump to search</a>\n<div class=\"mw-content-ltr\" dir=\"ltr\" id=\"mw-content-text\" lang=\"en\"><div class=\"mw-parser-output\"><table class=\"vertical-navbox nowraplinks\" style=\"float:right;clear:right;width:22.0em;margin:0 0 1.0em 1.0em;background:#f9f9f9;border:1px solid #aaa;padding:0.2em;border-spacing:0.4em 0;text-align:center;line-height:1.4em;font-size:88%\"><tbody><tr><th style=\"padding:0.2em 0.4em 0.2em;font-size:145%;line-height:1.2em\"><a href=\"/wiki/Programming_paradigm\" title=\"Programming paradigm\">Programming paradigms</a></th></tr><tr><td style=\"padding:0 0.1em 0.4em;text-align: left\">\n<ul><li><a href=\"/wiki/Action_language\" title=\"Action language\">Action</a></li>\n<li><a href=\"/wiki/Agent-oriented_programming\" title=\"Agent-oriented programming\">Agent-oriented</a></li>\n<li><a href=\"/wiki/Array_programming\" title=\"Array programming\">Array-oriented</a></li>\n<li><a href=\"/wiki/Automata-based_programming\" title=\"Automata-based programming\">Automata-based</a></li>\n<li><a href=\"/wiki/Concurrent_computing\" title=\"Concurrent computing\">Concurrent computing</a>\n<ul><li><a href=\"/wiki/Relativistic_programming\" title=\"Relativistic programming\">Relativistic programming</a></li></ul></li>\n<li><a href=\"/wiki/Data-driven_programming\" title=\"Data-driven programming\">Data-driven</a></li>\n<li><a href=\"/wiki/Declarative_programming\" title=\"Declarative programming\">Declarative</a> (contrast: <a href=\"/wiki/Imperative_programming\" title=\"Imperative programming\">Imperative</a>)\n<ul><li><a href=\"/wiki/Functional_programming\" title=\"Functional programming\">Functional</a>\n<ul><li><a href=\"/wiki/Functional_logic_programming\" title=\"Functional logic programming\">Functional logic</a></li>\n<li><a href=\"/wiki/Purely_functional_programming\" title=\"Purely functional programming\">Purely functional</a></li></ul></li>\n<li><a href=\"/wiki/Logic_programming\" title=\"Logic programming\">Logic</a>\n<ul><li><a href=\"/wiki/Abductive_logic_programming\" title=\"Abductive logic programming\">Abductive logic</a></li>\n<li><a href=\"/wiki/Answer_set_programming\" title=\"Answer set programming\">Answer set</a></li>\n<li><a href=\"/wiki/Concurrent_logic_programming\" title=\"Concurrent logic programming\">Concurrent logic</a></li>\n<li><a href=\"/wiki/Functional_logic_programming\" title=\"Functional logic programming\">Functional logic</a></li>\n<li><a href=\"/wiki/Inductive_logic_programming\" title=\"Inductive logic programming\">Inductive logic</a></li></ul></li>\n<li><a href=\"/wiki/Constraint_programming\" title=\"Constraint programming\">Constraint</a>\n<ul><li><a href=\"/wiki/Constraint_logic_programming\" title=\"Constraint logic programming\">Constraint logic</a>\n<ul><li><a href=\"/wiki/Concurrent_constraint_logic_programming\" title=\"Concurrent constraint logic programming\">Concurrent constraint logic</a></li></ul></li></ul></li>\n<li><a href=\"/wiki/Dataflow_programming\" title=\"Dataflow programming\">Dataflow</a>\n<ul><li><a href=\"/wiki/Flow-based_programming\" title=\"Flow-based programming\">Flow-based</a></li>\n<li><a href=\"/wiki/Reactive_programming\" title=\"Reactive programming\">Reactive</a></li></ul></li>\n<li><a href=\"/wiki/Ontology_language\" title=\"Ontology language\">Ontology</a></li></ul></li>\n<li><a href=\"/wiki/Differentiable_programming\" title=\"Differentiable programming\">Differentiable</a></li>\n<li><a href=\"/wiki/Dynamic_programming_language\" title=\"Dynamic programming language\">Dynamic/scripting</a></li>\n<li><a href=\"/wiki/Event-driven_programming\" title=\"Event-driven programming\">Event-driven</a></li>\n<li><a href=\"/wiki/Function-level_programming\" title=\"Function-level programming\">Function-level</a> (contrast: <a href=\"/wiki/Value-level_programming\" title=\"Value-level programming\">Value-level</a>)\n<ul><li><a href=\"/wiki/Tacit_programming\" title=\"Tacit programming\">Point-free style</a>\n<ul><li><a href=\"/wiki/Concatenative_programming_language\" title=\"Concatenative programming language\">Concatenative</a></li></ul></li></ul></li>\n<li><a href=\"/wiki/Generic_programming\" title=\"Generic programming\">Generic</a></li>\n<li><a href=\"/wiki/Imperative_programming\" title=\"Imperative programming\">Imperative</a> (contrast: <a href=\"/wiki/Declarative_programming\" title=\"Declarative programming\">Declarative</a>)\n<ul><li><a href=\"/wiki/Procedural_programming\" title=\"Procedural programming\">Procedural</a></li>\n<li><a href=\"/wiki/Object-oriented_programming\" title=\"Object-oriented programming\">Object-oriented</a></li></ul></li>\n<li><a href=\"/wiki/Literate_programming\" title=\"Literate programming\">Literate</a></li>\n<li><a href=\"/wiki/Language-oriented_programming\" title=\"Language-oriented programming\">Language-oriented</a>\n<ul><li><a href=\"/wiki/Natural-language_programming\" title=\"Natural-language programming\">Natural-language programming</a></li>\n<li><a href=\"/wiki/Service-oriented_modeling#Discipline-specific_modeling\" title=\"Service-oriented modeling\">Discipline-specific</a></li>\n<li><a href=\"/wiki/Domain-specific_language\" title=\"Domain-specific language\">Domain-specific</a></li>\n<li><a href=\"/wiki/Grammar-oriented_programming\" title=\"Grammar-oriented programming\">Grammar-oriented</a></li>\n<li><a href=\"/wiki/Intentional_programming\" title=\"Intentional programming\">Intentional</a></li></ul></li>\n<li><a href=\"/wiki/Metaprogramming\" title=\"Metaprogramming\">Metaprogramming</a>\n<ul><li><a href=\"/wiki/Automatic_programming\" title=\"Automatic programming\">Automatic</a>\n<ul><li><a class=\"mw-selflink selflink\">Inductive programming</a></li></ul></li>\n<li><a href=\"/wiki/Reflection_(computer_programming)\" title=\"Reflection (computer programming)\">Reflective</a>\n<ul><li><a href=\"/wiki/Attribute-oriented_programming\" title=\"Attribute-oriented programming\">Attribute-oriented</a></li></ul></li>\n<li><a href=\"/wiki/Macro_(computer_science)\" title=\"Macro (computer science)\">Macro</a></li>\n<li><a href=\"/wiki/Template_metaprogramming\" title=\"Template metaprogramming\">Template</a></li></ul></li>\n<li><a href=\"/wiki/Non-structured_programming\" title=\"Non-structured programming\">Non-structured</a> (contrast: <a href=\"/wiki/Structured_programming\" title=\"Structured programming\">Structured</a>)\n<ul><li><a href=\"/wiki/Array_programming\" title=\"Array programming\">Array</a></li></ul></li>\n<li><a href=\"/wiki/Nondeterministic_programming\" title=\"Nondeterministic programming\">Nondeterministic</a></li>\n<li><a href=\"/wiki/Parallel_computing\" title=\"Parallel computing\">Parallel computing</a>\n<ul><li><a href=\"/wiki/Process-oriented_programming\" title=\"Process-oriented programming\">Process-oriented</a></li></ul></li>\n<li><a href=\"/wiki/Probabilistic_programming_language\" title=\"Probabilistic programming language\">Probabilistic</a></li>\n<li><a href=\"/wiki/Stack-oriented_programming\" title=\"Stack-oriented programming\">Stack-based</a></li>\n<li><a href=\"/wiki/Structured_programming\" title=\"Structured programming\">Structured</a> (contrast: <a href=\"/wiki/Non-structured_programming\" title=\"Non-structured programming\">Non-structured</a>)\n<ul><li><a href=\"/wiki/Block_(programming)\" title=\"Block (programming)\">Block-structured</a></li>\n<li><a href=\"/wiki/Object-oriented_programming\" title=\"Object-oriented programming\">Object-oriented</a>\n<ul><li><a href=\"/wiki/Actor_model\" title=\"Actor model\">Actor-based</a></li>\n<li><a href=\"/wiki/Class-based_programming\" title=\"Class-based programming\">Class-based</a></li>\n<li><a href=\"/wiki/Concurrent_object-oriented_programming\" title=\"Concurrent object-oriented programming\">Concurrent</a></li>\n<li><a href=\"/wiki/Prototype-based_programming\" title=\"Prototype-based programming\">Prototype-based</a></li>\n<li>By <a href=\"/wiki/Separation_of_concerns\" title=\"Separation of concerns\">separation of concerns</a>:\n<ul><li><a href=\"/wiki/Aspect-oriented_programming\" title=\"Aspect-oriented programming\">Aspect-oriented</a></li>\n<li><a href=\"/wiki/Role-oriented_programming\" title=\"Role-oriented programming\">Role-oriented</a></li>\n<li><a href=\"/wiki/Subject-oriented_programming\" title=\"Subject-oriented programming\">Subject-oriented</a></li></ul></li></ul></li>\n<li><a href=\"/wiki/Recursion_(computer_science)\" title=\"Recursion (computer science)\">Recursive</a></li></ul></li>\n<li><a href=\"/wiki/Symbolic_programming\" title=\"Symbolic programming\">Symbolic</a></li>\n<li><a href=\"/wiki/Value-level_programming\" title=\"Value-level programming\">Value-level</a> (contrast: <a href=\"/wiki/Function-level_programming\" title=\"Function-level programming\">Function-level</a>)</li>\n<li><a href=\"/wiki/Quantum_programming\" title=\"Quantum programming\">Quantum programming</a></li></ul></td>\n</tr><tr><td style=\"text-align:right;font-size:115%\"><div class=\"plainlinks hlist navbar mini\"><ul><li class=\"nv-view\"><a href=\"/wiki/Template:Programming_paradigms\" title=\"Template:Programming paradigms\"><abbr title=\"View this template\">v</abbr></a></li><li class=\"nv-talk\"><a href=\"/wiki/Template_talk:Programming_paradigms\" title=\"Template talk:Programming paradigms\"><abbr title=\"Discuss this template\">t</abbr></a></li><li class=\"nv-edit\"><a class=\"external text\" href=\"//en.wikipedia.org/w/index.php?title=Template:Programming_paradigms&amp;action=edit\"><abbr title=\"Edit this template\">e</abbr></a></li></ul></div></td></tr></tbody></table>\n<p><b>Inductive programming</b> (<b>IP</b>) is a special area of <a href=\"/wiki/Automatic_programming\" title=\"Automatic programming\">automatic programming</a>, covering research from <a href=\"/wiki/Artificial_intelligence\" title=\"Artificial intelligence\">artificial intelligence</a> and <a href=\"/wiki/Computer_programming\" title=\"Computer programming\">programming</a>, which addresses <a href=\"/wiki/Machine_learning\" title=\"Machine learning\">learning</a> of typically <a href=\"/wiki/Declarative_programming\" title=\"Declarative programming\">declarative</a> (<a href=\"/wiki/Logic_programming\" title=\"Logic programming\">logic</a> or <a href=\"/wiki/Functional_programming\" title=\"Functional programming\">functional</a>) and often <a href=\"/wiki/Recursion\" title=\"Recursion\">recursive</a> programs from incomplete specifications, such as input/output examples or constraints.\n</p><p>Depending on the programming language used, there are several kinds of inductive programming. <b>Inductive functional programming</b>, which uses functional programming languages such as <a href=\"/wiki/Lisp_(programming_language)\" title=\"Lisp (programming language)\">Lisp</a> or <a href=\"/wiki/Haskell_(programming_language)\" title=\"Haskell (programming language)\">Haskell</a>, and most especially <a href=\"/wiki/Inductive_logic_programming\" title=\"Inductive logic programming\">inductive logic programming</a>, which uses logic programming languages such as <a href=\"/wiki/Prolog\" title=\"Prolog\">Prolog</a> and other logical representations  such as <a class=\"mw-redirect\" href=\"/wiki/Description_logics\" title=\"Description logics\">description logics</a>, have been more prominent, but other (programming) language paradigms have also been used, such as <a href=\"/wiki/Constraint_programming\" title=\"Constraint programming\">constraint programming</a> or <a href=\"/wiki/Probabilistic_programming_language\" title=\"Probabilistic programming language\">probabilistic programming</a>.\n</p>\n<div class=\"toc\" id=\"toc\"><input class=\"toctogglecheckbox\" id=\"toctogglecheckbox\" role=\"button\" style=\"display:none\" type=\"checkbox\"/><div class=\"toctitle\" dir=\"ltr\" lang=\"en\"><h2>Contents</h2><span class=\"toctogglespan\"><label class=\"toctogglelabel\" for=\"toctogglecheckbox\"></label></span></div>\n<ul>\n<li class=\"toclevel-1 tocsection-1\"><a href=\"#Definition\"><span class=\"tocnumber\">1</span> <span class=\"toctext\">Definition</span></a></li>\n<li class=\"toclevel-1 tocsection-2\"><a href=\"#History\"><span class=\"tocnumber\">2</span> <span class=\"toctext\">History</span></a></li>\n<li class=\"toclevel-1 tocsection-3\"><a href=\"#Application_areas\"><span class=\"tocnumber\">3</span> <span class=\"toctext\">Application areas</span></a></li>\n<li class=\"toclevel-1 tocsection-4\"><a href=\"#See_also\"><span class=\"tocnumber\">4</span> <span class=\"toctext\">See also</span></a></li>\n<li class=\"toclevel-1 tocsection-5\"><a href=\"#References\"><span class=\"tocnumber\">5</span> <span class=\"toctext\">References</span></a></li>\n<li class=\"toclevel-1 tocsection-6\"><a href=\"#Further_reading\"><span class=\"tocnumber\">6</span> <span class=\"toctext\">Further reading</span></a></li>\n<li class=\"toclevel-1 tocsection-7\"><a href=\"#External_links\"><span class=\"tocnumber\">7</span> <span class=\"toctext\">External links</span></a></li>\n</ul>\n</div>\n<h2><span class=\"mw-headline\" id=\"Definition\">Definition</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/w/index.php?title=Inductive_programming&amp;action=edit&amp;section=1\" title=\"Edit section: Definition\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n<p>Inductive programming incorporates all approaches which are concerned with learning programs or algorithms from incomplete (<a href=\"/wiki/Formal_specification\" title=\"Formal specification\">formal</a>) specifications. Possible inputs in an IP system are a set of training inputs and corresponding outputs or an output evaluation function, describing the desired behavior of the intended program, <a href=\"/wiki/Tracing_(software)\" title=\"Tracing (software)\">traces</a> or action sequences which describe the process of calculating specific outputs, <a href=\"/wiki/Constraint_(mathematics)\" title=\"Constraint (mathematics)\">constraints</a> for the program to be induced concerning its time efficiency or its complexity, various kinds of background knowledge such as standard <a href=\"/wiki/Data_type\" title=\"Data type\">data types</a>, predefined functions to be used, program schemes or templates describing the data flow of the intended program, heuristics for guiding the search for a solution or other biases.\n</p><p>Output of an IP system is a program in some arbitrary programming language containing conditionals and loop or recursive control structures, or any other kind of <a href=\"/wiki/Turing_completeness\" title=\"Turing completeness\">Turing-complete</a> <a href=\"/wiki/Knowledge_representation_and_reasoning\" title=\"Knowledge representation and reasoning\">representation</a> language.\n</p><p>In many applications the output program must be correct with respect to the examples and partial specification,  and this leads to the consideration of inductive programming as a special area inside automatic programming or <a href=\"/wiki/Program_synthesis\" title=\"Program synthesis\">program synthesis</a>,<sup class=\"reference\" id=\"cite_ref-1\"><a href=\"#cite_note-1\">[1]</a></sup><sup class=\"reference\" id=\"cite_ref-2\"><a href=\"#cite_note-2\">[2]</a></sup> usually opposed to 'deductive' program synthesis,<sup class=\"reference\" id=\"cite_ref-3\"><a href=\"#cite_note-3\">[3]</a></sup><sup class=\"reference\" id=\"cite_ref-4\"><a href=\"#cite_note-4\">[4]</a></sup><sup class=\"reference\" id=\"cite_ref-5\"><a href=\"#cite_note-5\">[5]</a></sup> where the specification is usually complete.\n</p><p>In other cases, inductive programming is seen as a more general area where any declarative programming or representation language can be used and we may even have some degree of error in the examples, as in general <a href=\"/wiki/Machine_learning\" title=\"Machine learning\">machine learning</a>, the more specific area of <a href=\"/wiki/Structure_mining\" title=\"Structure mining\">structure mining</a> or the area of <a href=\"/wiki/Symbolic_artificial_intelligence\" title=\"Symbolic artificial intelligence\">symbolic artificial intelligence</a>. A distinctive feature is the number of examples or partial specification needed. Typically, inductive programming techniques can learn from just a few examples.\n</p><p>The diversity of inductive programming usually comes from the applications and the languages that are used: apart from logic programming and functional programming, other programming paradigms and representation languages have been used or suggested in inductive programming, such as <a href=\"/wiki/Functional_logic_programming\" title=\"Functional logic programming\">functional logic programming</a>, <a href=\"/wiki/Constraint_programming\" title=\"Constraint programming\">constraint programming</a>, <a href=\"/wiki/Probabilistic_programming_language\" title=\"Probabilistic programming language\">probabilistic programming</a>, <a href=\"/wiki/Abductive_logic_programming\" title=\"Abductive logic programming\">abductive logic programming</a>, <a href=\"/wiki/Modal_logic\" title=\"Modal logic\">modal logic</a>, <a href=\"/wiki/Action_language\" title=\"Action language\">action languages</a>, agent languages and many types of <a class=\"mw-redirect\" href=\"/wiki/Imperative_languages\" title=\"Imperative languages\">imperative languages</a>.\n</p>\n<h2><span class=\"mw-headline\" id=\"History\">History</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/w/index.php?title=Inductive_programming&amp;action=edit&amp;section=2\" title=\"Edit section: History\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n<p>Research on the inductive synthesis of recursive functional programs started in the early 1970s and was brought onto firm theoretical foundations with the seminal THESIS system of Summers<sup class=\"reference\" id=\"cite_ref-6\"><a href=\"#cite_note-6\">[6]</a></sup> and work of Biermann.<sup class=\"reference\" id=\"cite_ref-7\"><a href=\"#cite_note-7\">[7]</a></sup>\nThese approaches were split into two phases: first, input-output examples are transformed into non-recursive programs (traces) using a small set of basic operators; second, regularities in the traces are searched for and used to fold them into a recursive program.  The main results until the mid 1980s are surveyed by Smith.<sup class=\"reference\" id=\"cite_ref-8\"><a href=\"#cite_note-8\">[8]</a></sup> Due to limited progress with respect to the range of programs that could be synthesized, research activities decreased significantly in the next decade.\n</p><p>The advent of logic programming brought a new elan but also a new direction in the early 1980s, especially due to the MIS system of Shapiro<sup class=\"reference\" id=\"cite_ref-9\"><a href=\"#cite_note-9\">[9]</a></sup> eventually spawning the new field of inductive logic programming (ILP).<sup class=\"reference\" id=\"cite_ref-10\"><a href=\"#cite_note-10\">[10]</a></sup> The early works of Plotkin,<sup class=\"reference\" id=\"cite_ref-11\"><a href=\"#cite_note-11\">[11]</a></sup><sup class=\"reference\" id=\"cite_ref-12\"><a href=\"#cite_note-12\">[12]</a></sup> and his \"<i>relative least general generalization (rlgg)</i>\", had an enormous impact in inductive logic programming. Most of ILP work addresses a wider class of problems, as the focus is not only on recursive logic programs but on machine learning of symbolic hypotheses from logical representations. However, there were some encouraging results on learning recursive Prolog programs such as quicksort from examples together with suitable background knowledge, for example with GOLEM.<sup class=\"reference\" id=\"cite_ref-13\"><a href=\"#cite_note-13\">[13]</a></sup> But again, after initial success, the community got disappointed by limited progress about the induction of recursive programs<sup class=\"reference\" id=\"cite_ref-14\"><a href=\"#cite_note-14\">[14]</a></sup><sup class=\"reference\" id=\"cite_ref-15\"><a href=\"#cite_note-15\">[15]</a></sup><sup class=\"reference\" id=\"cite_ref-16\"><a href=\"#cite_note-16\">[16]</a></sup> with ILP less and less focusing on recursive programs and leaning more and more towards a machine learning setting with applications in <a href=\"/wiki/Relational_data_mining\" title=\"Relational data mining\">relational data mining</a> and knowledge discovery.<sup class=\"reference\" id=\"cite_ref-17\"><a href=\"#cite_note-17\">[17]</a></sup>\n</p><p>In parallel to work in ILP, Koza<sup class=\"reference\" id=\"cite_ref-18\"><a href=\"#cite_note-18\">[18]</a></sup> proposed genetic programming in the early 1990s as a generate-and-test based approach to learning programs. The idea of genetic programming was further developed into the inductive programming system ADATE<sup class=\"reference\" id=\"cite_ref-19\"><a href=\"#cite_note-19\">[19]</a></sup> and the systematic-search-based system MagicHaskeller.<sup class=\"reference\" id=\"cite_ref-20\"><a href=\"#cite_note-20\">[20]</a></sup> Here again, functional programs are learned from sets of positive examples together with an output evaluation (fitness) function which specifies the desired input/output behavior of the program to be learned.\n</p><p>The early work in <a href=\"/wiki/Grammar_induction\" title=\"Grammar induction\">grammar induction</a> (also known as grammatical inference) is related to inductive programming, as rewriting systems or logic programs can be used to represent production rules. In fact, early works in inductive inference considered grammar induction and Lisp program inference as basically the same problem.<sup class=\"reference\" id=\"cite_ref-21\"><a href=\"#cite_note-21\">[21]</a></sup> The results in terms of learnability were related to classical concepts, such as identification-in-the-limit, as introduced in the seminal work of Gold.<sup class=\"reference\" id=\"cite_ref-22\"><a href=\"#cite_note-22\">[22]</a></sup> More recently, the language learning problem was addressed by the inductive programming community.<sup class=\"reference\" id=\"cite_ref-23\"><a href=\"#cite_note-23\">[23]</a></sup><sup class=\"reference\" id=\"cite_ref-24\"><a href=\"#cite_note-24\">[24]</a></sup>\n</p><p>In the recent years, the classical approaches have been resumed and advanced with great success. Therefore, the synthesis problem has been reformulated on the background of constructor-based term rewriting systems taking into account modern techniques of functional programming, as well as moderate use of search-based strategies and usage of background knowledge as well as automatic invention of subprograms. Many new and successful applications have recently appeared beyond program synthesis, most especially in the area of data manipulation, programming by example and cognitive modelling (see below).\n</p><p>Other ideas have also been explored with the common characteristic of using declarative languages for the representation of hypotheses. For instance, the use of higher-order features, schemes or structured distances have been advocated for a better handling of recursive data types and structures;<sup class=\"reference\" id=\"cite_ref-25\"><a href=\"#cite_note-25\">[25]</a></sup><sup class=\"reference\" id=\"cite_ref-26\"><a href=\"#cite_note-26\">[26]</a></sup><sup class=\"reference\" id=\"cite_ref-27\"><a href=\"#cite_note-27\">[27]</a></sup> abstraction has also been explored as a more powerful approach to <a href=\"/wiki/Cumulative_learning\" title=\"Cumulative learning\">cumulative learning</a> and function invention.<sup class=\"reference\" id=\"cite_ref-28\"><a href=\"#cite_note-28\">[28]</a></sup><sup class=\"reference\" id=\"cite_ref-29\"><a href=\"#cite_note-29\">[29]</a></sup>\n</p><p>One powerful paradigm that has been recently used for the representation of hypotheses in inductive programming (generally in the form of <a href=\"/wiki/Generative_model\" title=\"Generative model\">generative models</a>) is <a href=\"/wiki/Probabilistic_programming_language\" title=\"Probabilistic programming language\">probabilistic programming</a> (and related paradigms, such as stochastic logic programs and Bayesian logic programming).<sup class=\"reference\" id=\"cite_ref-30\"><a href=\"#cite_note-30\">[30]</a></sup><sup class=\"reference\" id=\"cite_ref-31\"><a href=\"#cite_note-31\">[31]</a></sup><sup class=\"reference\" id=\"cite_ref-32\"><a href=\"#cite_note-32\">[32]</a></sup><sup class=\"reference\" id=\"cite_ref-33\"><a href=\"#cite_note-33\">[33]</a></sup>\n</p>\n<h2><span class=\"mw-headline\" id=\"Application_areas\">Application areas</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/w/index.php?title=Inductive_programming&amp;action=edit&amp;section=3\" title=\"Edit section: Application areas\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n<p>The <a class=\"external text\" href=\"http://www.cogsys.wiai.uni-bamberg.de/aaip05/objectives.html\" rel=\"nofollow\">first workshop on Approaches and Applications of Inductive Programming (AAIP) </a> held in conjunction with <a class=\"mw-redirect\" href=\"/wiki/ICML\" title=\"ICML\">ICML</a> 2005 identified all applications where \"learning of programs or recursive rules are called for, [...] first in the domain of software engineering where structural learning, software assistants and software agents can help to relieve programmers from routine tasks, give programming support for end users, or support of novice programmers and programming tutor systems. Further areas of application are language learning, learning recursive control rules for AI-planning, learning recursive concepts in web-mining or for data-format transformations\".\n</p><p>Since then, these and many other areas have shown to be successful application niches for inductive programming, such as <a href=\"/wiki/End-user_development\" title=\"End-user development\">end-user programming</a>,<sup class=\"reference\" id=\"cite_ref-34\"><a href=\"#cite_note-34\">[34]</a></sup> the related areas of <a href=\"/wiki/Programming_by_example\" title=\"Programming by example\">programming by example</a><sup class=\"reference\" id=\"cite_ref-35\"><a href=\"#cite_note-35\">[35]</a></sup> and <a href=\"/wiki/Programming_by_demonstration\" title=\"Programming by demonstration\">programming by demonstration</a>,<sup class=\"reference\" id=\"cite_ref-36\"><a href=\"#cite_note-36\">[36]</a></sup> and <a href=\"/wiki/Intelligent_tutoring_system\" title=\"Intelligent tutoring system\">intelligent tutoring systems</a>.\n</p><p>Other areas where inductive inference has been recently applied are <a href=\"/wiki/Knowledge_acquisition\" title=\"Knowledge acquisition\">knowledge acquisition</a>,<sup class=\"reference\" id=\"cite_ref-37\"><a href=\"#cite_note-37\">[37]</a></sup> <a href=\"/wiki/Artificial_general_intelligence\" title=\"Artificial general intelligence\">artificial general intelligence</a>,<sup class=\"reference\" id=\"cite_ref-38\"><a href=\"#cite_note-38\">[38]</a></sup> <a href=\"/wiki/Reinforcement_learning\" title=\"Reinforcement learning\">reinforcement learning</a> and theory evaluation,<sup class=\"reference\" id=\"cite_ref-39\"><a href=\"#cite_note-39\">[39]</a></sup><sup class=\"reference\" id=\"cite_ref-40\"><a href=\"#cite_note-40\">[40]</a></sup> and <a href=\"/wiki/Cognitive_science\" title=\"Cognitive science\">cognitive science</a> in general.<sup class=\"reference\" id=\"cite_ref-41\"><a href=\"#cite_note-41\">[41]</a></sup><sup class=\"reference\" id=\"cite_ref-42\"><a href=\"#cite_note-42\">[42]</a></sup> There may also be prospective applications in intelligent agents, games, robotics, personalisation, ambient intelligence and human interfaces.\n</p>\n<h2><span class=\"mw-headline\" id=\"See_also\">See also</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/w/index.php?title=Inductive_programming&amp;action=edit&amp;section=4\" title=\"Edit section: See also\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n<ul><li><a href=\"/wiki/Automatic_programming\" title=\"Automatic programming\">Automatic programming</a></li>\n<li><a href=\"/wiki/Declarative_programming\" title=\"Declarative programming\">Declarative programming</a></li>\n<li><a href=\"/wiki/Evolutionary_programming\" title=\"Evolutionary programming\">Evolutionary programming</a></li>\n<li><a href=\"/wiki/Functional_programming\" title=\"Functional programming\">Functional programming</a></li>\n<li><a href=\"/wiki/Genetic_programming\" title=\"Genetic programming\">Genetic programming</a></li>\n<li><a href=\"/wiki/Grammar_induction\" title=\"Grammar induction\">Grammar induction</a></li>\n<li><a href=\"/wiki/Inductive_reasoning\" title=\"Inductive reasoning\">Inductive reasoning</a></li>\n<li><a href=\"/wiki/Inductive_logic_programming\" title=\"Inductive logic programming\">Inductive logic programming</a></li>\n<li><a href=\"/wiki/Logic_programming\" title=\"Logic programming\">Logic programming</a></li>\n<li><a href=\"/wiki/Machine_learning\" title=\"Machine learning\">Machine learning</a></li>\n<li><a href=\"/wiki/Probabilistic_programming_language\" title=\"Probabilistic programming language\">Probabilistic programming language</a></li>\n<li><a href=\"/wiki/Program_synthesis\" title=\"Program synthesis\">Program synthesis</a></li>\n<li><a href=\"/wiki/Programming_by_example\" title=\"Programming by example\">Programming by example</a></li>\n<li><a href=\"/wiki/Programming_by_demonstration\" title=\"Programming by demonstration\">Programming by demonstration</a></li>\n<li><a href=\"/wiki/Structure_mining\" title=\"Structure mining\">Structure mining</a></li>\n<li><a href=\"/wiki/Test-driven_development\" title=\"Test-driven development\">Test-driven development</a></li></ul>\n<h2><span class=\"mw-headline\" id=\"References\">References</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/w/index.php?title=Inductive_programming&amp;action=edit&amp;section=5\" title=\"Edit section: References\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n<div class=\"reflist\" style=\"list-style-type: decimal;\">\n<div class=\"mw-references-wrap mw-references-columns\"><ol class=\"references\">\n<li id=\"cite_note-1\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-1\">^</a></b></span> <span class=\"reference-text\"><cite class=\"citation journal\">Biermann, A.W. (1992).  Shapiro, S.C., ed. \"Automatic programming\". <i>Encyclopedia of Artificial Intelligence</i>: 18–35.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Encyclopedia+of+Artificial+Intelligence&amp;rft.atitle=Automatic+programming&amp;rft.pages=18-35&amp;rft.date=1992&amp;rft.aulast=Biermann&amp;rft.aufirst=A.W.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><style data-mw-deduplicate=\"TemplateStyles:r879151008\">.mw-parser-output cite.citation{font-style:inherit}.mw-parser-output .citation q{quotes:\"\\\"\"\"\\\"\"\"'\"\"'\"}.mw-parser-output .citation .cs1-lock-free a{background:url(\"//upload.wikimedia.org/wikipedia/commons/thumb/6/65/Lock-green.svg/9px-Lock-green.svg.png\")no-repeat;background-position:right .1em center}.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:url(\"//upload.wikimedia.org/wikipedia/commons/thumb/d/d6/Lock-gray-alt-2.svg/9px-Lock-gray-alt-2.svg.png\")no-repeat;background-position:right .1em center}.mw-parser-output .citation .cs1-lock-subscription a{background:url(\"//upload.wikimedia.org/wikipedia/commons/thumb/a/aa/Lock-red-alt-2.svg/9px-Lock-red-alt-2.svg.png\")no-repeat;background-position:right .1em center}.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registration{color:#555}.mw-parser-output .cs1-subscription span,.mw-parser-output .cs1-registration span{border-bottom:1px dotted;cursor:help}.mw-parser-output .cs1-ws-icon a{background:url(\"//upload.wikimedia.org/wikipedia/commons/thumb/4/4c/Wikisource-logo.svg/12px-Wikisource-logo.svg.png\")no-repeat;background-position:right .1em center}.mw-parser-output code.cs1-code{color:inherit;background:inherit;border:inherit;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;font-size:100%}.mw-parser-output .cs1-visible-error{font-size:100%}.mw-parser-output .cs1-maint{display:none;color:#33aa33;margin-left:0.3em}.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registration,.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left,.mw-parser-output .cs1-kern-wl-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right,.mw-parser-output .cs1-kern-wl-right{padding-right:0.2em}</style></span>\n</li>\n<li id=\"cite_note-2\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-2\">^</a></b></span> <span class=\"reference-text\"><cite class=\"citation book\">Rich, C.; Waters, R.C. (1993).  Yovits, M.C., ed. <a class=\"external text\" href=\"http://www.merl.com/publications/docs/TR92-04.pdf\" rel=\"nofollow\"><i>Approaches to automatic programming</i></a> <span class=\"cs1-format\">(PDF)</span>. <i>Advances in Computers</i>. <b>37</b>. pp. 1–57. <a href=\"/wiki/Digital_object_identifier\" title=\"Digital object identifier\">doi</a>:<a class=\"external text\" href=\"//doi.org/10.1016%2FS0065-2458%2808%2960402-7\" rel=\"nofollow\">10.1016/S0065-2458(08)60402-7</a>. <a href=\"/wiki/International_Standard_Book_Number\" title=\"International Standard Book Number\">ISBN</a> <a href=\"/wiki/Special:BookSources/9780120121373\" title=\"Special:BookSources/9780120121373\">9780120121373</a>.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Approaches+to+automatic+programming&amp;rft.pages=1-57&amp;rft.date=1993&amp;rft_id=info%3Adoi%2F10.1016%2FS0065-2458%2808%2960402-7&amp;rft.isbn=9780120121373&amp;rft.aulast=Rich&amp;rft.aufirst=C.&amp;rft.au=Waters%2C+R.C.&amp;rft_id=http%3A%2F%2Fwww.merl.com%2Fpublications%2Fdocs%2FTR92-04.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-3\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-3\">^</a></b></span> <span class=\"reference-text\"><cite class=\"citation book\">Lowry, M.L.; McCarthy, R.D., eds. (1991). <i>Automatic software design</i>.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Automatic+software+design&amp;rft.date=1991&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-4\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-4\">^</a></b></span> <span class=\"reference-text\"><cite class=\"citation journal\">Manna, Z.; Waldinger, R. (1992). \"Fundamentals of deductive program synthesis\". <i>IEEE Trans Softw Eng</i>. <b>18</b> (8): 674–704. <a href=\"/wiki/CiteSeerX\" title=\"CiteSeerX\">CiteSeerX</a> <span class=\"cs1-lock-free\" title=\"Freely accessible\"><a class=\"external text\" href=\"//citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.51.817\" rel=\"nofollow\">10.1.1.51.817</a></span>. <a href=\"/wiki/Digital_object_identifier\" title=\"Digital object identifier\">doi</a>:<a class=\"external text\" href=\"//doi.org/10.1109%2F32.153379\" rel=\"nofollow\">10.1109/32.153379</a>.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=IEEE+Trans+Softw+Eng&amp;rft.atitle=Fundamentals+of+deductive+program+synthesis&amp;rft.volume=18&amp;rft.issue=8&amp;rft.pages=674-704&amp;rft.date=1992&amp;rft_id=%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fsummary%3Fdoi%3D10.1.1.51.817&amp;rft_id=info%3Adoi%2F10.1109%2F32.153379&amp;rft.aulast=Manna&amp;rft.aufirst=Z.&amp;rft.au=Waldinger%2C+R.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-5\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-5\">^</a></b></span> <span class=\"reference-text\"><cite class=\"citation book\">Flener, P. (2002).  Kakas, A.; Sadri, F., eds. <i>Achievements and prospects of program synthesis</i>. <i>Computational Logic: Logic Programming and Beyond; Essays in Honour of Robert A. Kowalski</i>. Lecture Notes in Computer Science. LNAI 2407. pp. 310–346. <a href=\"/wiki/Digital_object_identifier\" title=\"Digital object identifier\">doi</a>:<a class=\"external text\" href=\"//doi.org/10.1007%2F3-540-45628-7_13\" rel=\"nofollow\">10.1007/3-540-45628-7_13</a>. <a href=\"/wiki/International_Standard_Book_Number\" title=\"International Standard Book Number\">ISBN</a> <a href=\"/wiki/Special:BookSources/978-3-540-43959-2\" title=\"Special:BookSources/978-3-540-43959-2\">978-3-540-43959-2</a>.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Achievements+and+prospects+of+program+synthesis&amp;rft.series=Lecture+Notes+in+Computer+Science&amp;rft.pages=310-346&amp;rft.date=2002&amp;rft_id=info%3Adoi%2F10.1007%2F3-540-45628-7_13&amp;rft.isbn=978-3-540-43959-2&amp;rft.aulast=Flener&amp;rft.aufirst=P.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-6\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-6\">^</a></b></span> <span class=\"reference-text\"><cite class=\"citation journal\">Summers, P.D. (1977). \"A methodology for LISP program construction from examples\". <i>J ACM</i>. <b>24</b> (1): 161–175. <a href=\"/wiki/Digital_object_identifier\" title=\"Digital object identifier\">doi</a>:<a class=\"external text\" href=\"//doi.org/10.1145%2F321992.322002\" rel=\"nofollow\">10.1145/321992.322002</a>.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=J+ACM&amp;rft.atitle=A+methodology+for+LISP+program+construction+from+examples&amp;rft.volume=24&amp;rft.issue=1&amp;rft.pages=161-175&amp;rft.date=1977&amp;rft_id=info%3Adoi%2F10.1145%2F321992.322002&amp;rft.aulast=Summers&amp;rft.aufirst=P.D.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-7\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-7\">^</a></b></span> <span class=\"reference-text\"><cite class=\"citation journal\">Biermann, A.W. (1978). \"The inference of regular LISP programs from examples\". <i>IEEE Trans Syst Man Cybern</i>. <b>8</b> (8): 585–600. <a href=\"/wiki/Digital_object_identifier\" title=\"Digital object identifier\">doi</a>:<a class=\"external text\" href=\"//doi.org/10.1109%2Ftsmc.1978.4310035\" rel=\"nofollow\">10.1109/tsmc.1978.4310035</a>.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=IEEE+Trans+Syst+Man+Cybern&amp;rft.atitle=The+inference+of+regular+LISP+programs+from+examples&amp;rft.volume=8&amp;rft.issue=8&amp;rft.pages=585-600&amp;rft.date=1978&amp;rft_id=info%3Adoi%2F10.1109%2Ftsmc.1978.4310035&amp;rft.aulast=Biermann&amp;rft.aufirst=A.W.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-8\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-8\">^</a></b></span> <span class=\"reference-text\"><cite class=\"citation journal\">Smith, D.R. (1984).  Biermann, A.W.; Guiho, G., eds. <a class=\"external text\" href=\"https://www.researchgate.net/publication/239059541\" rel=\"nofollow\">\"The synthesis of LISP programs from examples: a survey\"</a>. <i>Automatic Program Construction Techniques</i>: 307–324.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Automatic+Program+Construction+Techniques&amp;rft.atitle=The+synthesis+of+LISP+programs+from+examples%3A+a+survey&amp;rft.pages=307-324&amp;rft.date=1984&amp;rft.aulast=Smith&amp;rft.aufirst=D.R.&amp;rft_id=https%3A%2F%2Fwww.researchgate.net%2Fpublication%2F239059541&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-9\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-9\">^</a></b></span> <span class=\"reference-text\"><cite class=\"citation book\">Shapiro, E.Y. (1983). <i>Algorithmic program debugging</i>. The MIT Press.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Algorithmic+program+debugging&amp;rft.pub=The+MIT+Press&amp;rft.date=1983&amp;rft.aulast=Shapiro&amp;rft.aufirst=E.Y.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-10\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-10\">^</a></b></span> <span class=\"reference-text\"><cite class=\"citation journal\">Muggleton, S. (1991). \"Inductive logic programming\". <i>New Generation Computing</i>. <b>8</b> (4): 295–318. <a href=\"/wiki/CiteSeerX\" title=\"CiteSeerX\">CiteSeerX</a> <span class=\"cs1-lock-free\" title=\"Freely accessible\"><a class=\"external text\" href=\"//citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.329.5312\" rel=\"nofollow\">10.1.1.329.5312</a></span>. <a href=\"/wiki/Digital_object_identifier\" title=\"Digital object identifier\">doi</a>:<a class=\"external text\" href=\"//doi.org/10.1007%2FBF03037089\" rel=\"nofollow\">10.1007/BF03037089</a>.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=New+Generation+Computing&amp;rft.atitle=Inductive+logic+programming&amp;rft.volume=8&amp;rft.issue=4&amp;rft.pages=295-318&amp;rft.date=1991&amp;rft_id=%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fsummary%3Fdoi%3D10.1.1.329.5312&amp;rft_id=info%3Adoi%2F10.1007%2FBF03037089&amp;rft.aulast=Muggleton&amp;rft.aufirst=S.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-11\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-11\">^</a></b></span> <span class=\"reference-text\"><cite class=\"citation journal\">Plotkin, Gordon D. (1970).  Meltzer, B.; Michie, D., eds. <a class=\"external text\" href=\"http://homepages.inf.ed.ac.uk/gdp/publications/MI5_note_ind_gen.pdf\" rel=\"nofollow\">\"A Note on Inductive Generalization\"</a> <span class=\"cs1-format\">(PDF)</span>. <i>Machine Intelligence</i>. <b>5</b>: 153–163.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Machine+Intelligence&amp;rft.atitle=A+Note+on+Inductive+Generalization&amp;rft.volume=5&amp;rft.pages=153-163&amp;rft.date=1970&amp;rft.aulast=Plotkin&amp;rft.aufirst=Gordon+D.&amp;rft_id=http%3A%2F%2Fhomepages.inf.ed.ac.uk%2Fgdp%2Fpublications%2FMI5_note_ind_gen.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-12\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-12\">^</a></b></span> <span class=\"reference-text\"><cite class=\"citation journal\">Plotkin, Gordon D. (1971).  Meltzer, B.; Michie, D., eds. \"A Further Note on Inductive Generalization\". <i>Machine Intelligence</i>. <b>6</b>: 101–124.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Machine+Intelligence&amp;rft.atitle=A+Further+Note+on+Inductive+Generalization&amp;rft.volume=6&amp;rft.pages=101-124&amp;rft.date=1971&amp;rft.aulast=Plotkin&amp;rft.aufirst=Gordon+D.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-13\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-13\">^</a></b></span> <span class=\"reference-text\"><cite class=\"citation journal\">Muggleton, S.H.; Feng, C. (1990). <a class=\"external text\" href=\"https://pdfs.semanticscholar.org/6a66/9636e0ada62a0fb444e95435e24fdbdf4dbd.pdf\" rel=\"nofollow\">\"Efficient induction of logic programs\"</a> <span class=\"cs1-format\">(PDF)</span>. <i>Proceedings of the Workshop on Algorithmic Learning Theory</i>. <b>6</b>: 368–381.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Proceedings+of+the+Workshop+on+Algorithmic+Learning+Theory&amp;rft.atitle=Efficient+induction+of+logic+programs&amp;rft.volume=6&amp;rft.pages=368-381&amp;rft.date=1990&amp;rft.aulast=Muggleton&amp;rft.aufirst=S.H.&amp;rft.au=Feng%2C+C.&amp;rft_id=https%3A%2F%2Fpdfs.semanticscholar.org%2F6a66%2F9636e0ada62a0fb444e95435e24fdbdf4dbd.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-14\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-14\">^</a></b></span> <span class=\"reference-text\"><cite class=\"citation journal\">Quinlan, J.R.; Cameron-Jones, R.M. (1993). <a class=\"external text\" href=\"https://pdfs.semanticscholar.org/4af3/18f1d267889faec6ecf1be6bc5fe570838dd.pdf\" rel=\"nofollow\">\"Avoiding Pitfalls When Learning Recursive Theories\"</a> <span class=\"cs1-format\">(PDF)</span>. <i>IJCAI</i>: 1050–1057.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=IJCAI&amp;rft.atitle=Avoiding+Pitfalls+When+Learning+Recursive+Theories&amp;rft.pages=1050-1057&amp;rft.date=1993&amp;rft.aulast=Quinlan&amp;rft.aufirst=J.R.&amp;rft.au=Cameron-Jones%2C+R.M.&amp;rft_id=https%3A%2F%2Fpdfs.semanticscholar.org%2F4af3%2F18f1d267889faec6ecf1be6bc5fe570838dd.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-15\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-15\">^</a></b></span> <span class=\"reference-text\">\n<cite class=\"citation journal\">Quinlan, J.R.; Cameron-Jones, R.M. (1995). <a class=\"external text\" href=\"http://dottorato.di.uniba.it/dottoratoXXVI/dm/FOILvsRelatedSystems.pdf\" rel=\"nofollow\">\"Induction of logic programs: FOIL and related systems\"</a> <span class=\"cs1-format\">(PDF)</span>. <b>13</b> (3–4). Springer: 287–312.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=Induction+of+logic+programs%3A+FOIL+and+related+systems&amp;rft.volume=13&amp;rft.issue=3%E2%80%934&amp;rft.pages=287-312&amp;rft.date=1995&amp;rft.aulast=Quinlan&amp;rft.aufirst=J.R.&amp;rft.au=Cameron-Jones%2C+R.M.&amp;rft_id=http%3A%2F%2Fdottorato.di.uniba.it%2FdottoratoXXVI%2Fdm%2FFOILvsRelatedSystems.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-16\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-16\">^</a></b></span> <span class=\"reference-text\">\n<cite class=\"citation journal\">Flener, P.; Yilmaz, S. (1999). \"Inductive synthesis of recursive logic programs: Achievements and prospects\". <i>The Journal of Logic Programming</i>. <b>41</b> (2): 141–195. <a href=\"/wiki/Digital_object_identifier\" title=\"Digital object identifier\">doi</a>:<a class=\"external text\" href=\"//doi.org/10.1016%2Fs0743-1066%2899%2900028-x\" rel=\"nofollow\">10.1016/s0743-1066(99)00028-x</a>.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=The+Journal+of+Logic+Programming&amp;rft.atitle=Inductive+synthesis+of+recursive+logic+programs%3A+Achievements+and+prospects&amp;rft.volume=41&amp;rft.issue=2&amp;rft.pages=141-195&amp;rft.date=1999&amp;rft_id=info%3Adoi%2F10.1016%2Fs0743-1066%2899%2900028-x&amp;rft.aulast=Flener&amp;rft.aufirst=P.&amp;rft.au=Yilmaz%2C+S.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-17\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-17\">^</a></b></span> <span class=\"reference-text\"><cite class=\"citation\" id=\"CITEREFDžeroski1996\">Džeroski, Sašo (1996), \"Inductive Logic Programming and Knowledge Discovery in Databases\",  in Fayyad, U.M.; Piatetsky-Shapiro, G.; Smith, P.; Uthurusamy, R., <i>Advances in Knowledge Discovery and Data Mining</i>, MIT Press, pp. 117–152</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.atitle=Inductive+Logic+Programming+and+Knowledge+Discovery+in+Databases&amp;rft.btitle=Advances+in+Knowledge+Discovery+and+Data+Mining&amp;rft.pages=117-152&amp;rft.pub=MIT+Press&amp;rft.date=1996&amp;rft.aulast=D%C5%BEeroski&amp;rft.aufirst=Sa%C5%A1o&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-18\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-18\">^</a></b></span> <span class=\"reference-text\">\n<cite class=\"citation book\">Koza, J.R. (1992). <a class=\"external text\" href=\"https://books.google.com/books?id=Bhtxo60BV0EC\" rel=\"nofollow\"><i>Genetic Programming: vol. 1, On the programming of computers by means of natural selection</i></a>. MIT Press. <a href=\"/wiki/International_Standard_Book_Number\" title=\"International Standard Book Number\">ISBN</a> <a href=\"/wiki/Special:BookSources/9780262111706\" title=\"Special:BookSources/9780262111706\">9780262111706</a>.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Genetic+Programming%3A+vol.+1%2C+On+the+programming+of+computers+by+means+of+natural+selection&amp;rft.pub=MIT+Press&amp;rft.date=1992&amp;rft.isbn=9780262111706&amp;rft.aulast=Koza&amp;rft.aufirst=J.R.&amp;rft_id=https%3A%2F%2Fbooks.google.com%2Fbooks%3Fid%3DBhtxo60BV0EC&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-19\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-19\">^</a></b></span> <span class=\"reference-text\">\n<cite class=\"citation journal\">Olsson, J.R. (1995). \"Inductive functional programming using incremental program transformation\". <i>Artificial Intelligence</i>. <b>74</b> (1): 55–83. <a href=\"/wiki/Digital_object_identifier\" title=\"Digital object identifier\">doi</a>:<a class=\"external text\" href=\"//doi.org/10.1016%2F0004-3702%2894%2900042-y\" rel=\"nofollow\">10.1016/0004-3702(94)00042-y</a>.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Artificial+Intelligence&amp;rft.atitle=Inductive+functional+programming+using+incremental+program+transformation&amp;rft.volume=74&amp;rft.issue=1&amp;rft.pages=55-83&amp;rft.date=1995&amp;rft_id=info%3Adoi%2F10.1016%2F0004-3702%2894%2900042-y&amp;rft.aulast=Olsson&amp;rft.aufirst=J.R.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-20\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-20\">^</a></b></span> <span class=\"reference-text\">\n<cite class=\"citation book\">Katayama, Susumu (2008). <a class=\"external text\" href=\"http://nautilus.cs.miyazaki-u.ac.jp/~skata/skatayama_pricai2008.pdf\" rel=\"nofollow\"><i>Efficient exhaustive generation of functional programs using Monte-Carlo search with iterative deepening</i></a> <span class=\"cs1-format\">(PDF)</span>. <i>PRICAI 2008: Trends in Artificial Intelligence</i>. Lecture Notes in Computer Science. <b>5351</b>. pp. 199–210. <a href=\"/wiki/CiteSeerX\" title=\"CiteSeerX\">CiteSeerX</a> <span class=\"cs1-lock-free\" title=\"Freely accessible\"><a class=\"external text\" href=\"//citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.606.1447\" rel=\"nofollow\">10.1.1.606.1447</a></span>. <a href=\"/wiki/Digital_object_identifier\" title=\"Digital object identifier\">doi</a>:<a class=\"external text\" href=\"//doi.org/10.1007%2F978-3-540-89197-0_21\" rel=\"nofollow\">10.1007/978-3-540-89197-0_21</a>. <a href=\"/wiki/International_Standard_Book_Number\" title=\"International Standard Book Number\">ISBN</a> <a href=\"/wiki/Special:BookSources/978-3-540-89196-3\" title=\"Special:BookSources/978-3-540-89196-3\">978-3-540-89196-3</a>.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Efficient+exhaustive+generation+of+functional+programs+using+Monte-Carlo+search+with+iterative+deepening&amp;rft.series=Lecture+Notes+in+Computer+Science&amp;rft.pages=199-210&amp;rft.date=2008&amp;rft_id=%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fsummary%3Fdoi%3D10.1.1.606.1447&amp;rft_id=info%3Adoi%2F10.1007%2F978-3-540-89197-0_21&amp;rft.isbn=978-3-540-89196-3&amp;rft.aulast=Katayama&amp;rft.aufirst=Susumu&amp;rft_id=http%3A%2F%2Fnautilus.cs.miyazaki-u.ac.jp%2F~skata%2Fskatayama_pricai2008.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-21\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-21\">^</a></b></span> <span class=\"reference-text\">\n<cite class=\"citation journal\">Angluin, D.; C.H., Smith (1983). \"Inductive inference: Theory and methods\". <i>ACM Computing Surveys</i>. <b>15</b> (3): 237–269. <a href=\"/wiki/Digital_object_identifier\" title=\"Digital object identifier\">doi</a>:<a class=\"external text\" href=\"//doi.org/10.1145%2F356914.356918\" rel=\"nofollow\">10.1145/356914.356918</a>.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=ACM+Computing+Surveys&amp;rft.atitle=Inductive+inference%3A+Theory+and+methods&amp;rft.volume=15&amp;rft.issue=3&amp;rft.pages=237-269&amp;rft.date=1983&amp;rft_id=info%3Adoi%2F10.1145%2F356914.356918&amp;rft.aulast=Angluin&amp;rft.aufirst=D.&amp;rft.au=C.H.%2C+Smith&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-22\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-22\">^</a></b></span> <span class=\"reference-text\">\n<cite class=\"citation journal\">Gold, E.M. (1967). <a class=\"external text\" href=\"https://web.archive.org/web/20090125120159/http://www.isrl.uiuc.edu/~amag/langev/paper/gold67limit.html\" rel=\"nofollow\">\"Language identification in the limit\"</a>. <i>Information and Control</i>. <b>10</b> (5): 447–474. <a href=\"/wiki/Digital_object_identifier\" title=\"Digital object identifier\">doi</a>:<a class=\"external text\" href=\"//doi.org/10.1016%2Fs0019-9958%2867%2991165-5\" rel=\"nofollow\">10.1016/s0019-9958(67)91165-5</a>. Archived from <a class=\"external text\" href=\"http://www.isrl.uiuc.edu/~amag/langev/paper/gold67limit.html\" rel=\"nofollow\">the original</a> on 2009-01-25.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Information+and+Control&amp;rft.atitle=Language+identification+in+the+limit&amp;rft.volume=10&amp;rft.issue=5&amp;rft.pages=447-474&amp;rft.date=1967&amp;rft_id=info%3Adoi%2F10.1016%2Fs0019-9958%2867%2991165-5&amp;rft.aulast=Gold&amp;rft.aufirst=E.M.&amp;rft_id=http%3A%2F%2Fwww.isrl.uiuc.edu%2F~amag%2Flangev%2Fpaper%2Fgold67limit.html&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-23\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-23\">^</a></b></span> <span class=\"reference-text\"><cite class=\"citation journal\">Muggleton, Stephen (1999). \"Inductive Logic Programming: Issues, Results and the Challenge of Learning Language in Logic\". <i>Artificial Intelligence</i>. <b>114</b> (1–2): 283–296. <a href=\"/wiki/Digital_object_identifier\" title=\"Digital object identifier\">doi</a>:<a class=\"external text\" href=\"//doi.org/10.1016%2Fs0004-3702%2899%2900067-3\" rel=\"nofollow\">10.1016/s0004-3702(99)00067-3</a>.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Artificial+Intelligence&amp;rft.atitle=Inductive+Logic+Programming%3A+Issues%2C+Results+and+the+Challenge+of+Learning+Language+in+Logic&amp;rft.volume=114&amp;rft.issue=1%E2%80%932&amp;rft.pages=283-296&amp;rft.date=1999&amp;rft_id=info%3Adoi%2F10.1016%2Fs0004-3702%2899%2900067-3&amp;rft.aulast=Muggleton&amp;rft.aufirst=Stephen&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/>; here: Sect.2.1</span>\n</li>\n<li id=\"cite_note-24\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-24\">^</a></b></span> <span class=\"reference-text\">\n<cite class=\"citation journal\">Olsson, J.R.; Powers, D.M.W. (2003). \"Machine learning of human language through automatic programming\". <i>Proceedings of the International Conference on Cognitive Science</i>: 507–512.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Proceedings+of+the+International+Conference+on+Cognitive+Science&amp;rft.atitle=Machine+learning+of+human+language+through+automatic+programming&amp;rft.pages=507-512&amp;rft.date=2003&amp;rft.aulast=Olsson&amp;rft.aufirst=J.R.&amp;rft.au=Powers%2C+D.M.W.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-25\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-25\">^</a></b></span> <span class=\"reference-text\">\n<cite class=\"citation journal\">Lloyd, J.W. (2001). <a class=\"external text\" href=\"http://users.cecs.anu.edu.au/~jwl/logic.pdf\" rel=\"nofollow\">\"Knowledge Representation, Computation, and Learning in Higher-order Logic\"</a> <span class=\"cs1-format\">(PDF)</span>.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=Knowledge+Representation%2C+Computation%2C+and+Learning+in+Higher-order+Logic&amp;rft.date=2001&amp;rft.aulast=Lloyd&amp;rft.aufirst=J.W.&amp;rft_id=http%3A%2F%2Fusers.cecs.anu.edu.au%2F~jwl%2Flogic.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-26\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-26\">^</a></b></span> <span class=\"reference-text\">\n<cite class=\"citation book\">Lloyd, J.W. (2003). <i>Logic for learning: learning comprehensible theories from structured data</i>. Springer.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Logic+for+learning%3A+learning+comprehensible+theories+from+structured+data&amp;rft.pub=Springer&amp;rft.date=2003&amp;rft.aulast=Lloyd&amp;rft.aufirst=J.W.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-27\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-27\">^</a></b></span> <span class=\"reference-text\">\n<cite class=\"citation journal\">Estruch, V.; Ferri, C.; Hernandez-Orallo, J.; Ramirez-Quintana, M.J. (2014). <a class=\"external text\" href=\"https://pdfs.semanticscholar.org/48f2/2821220555f8e327c2aa9614fb28c98f9542.pdf\" rel=\"nofollow\">\"Bridging the gap between distance and generalization\"</a> <span class=\"cs1-format\">(PDF)</span>. <i>Computational Intelligence</i>. <b>30</b> (3): 473–513. <a href=\"/wiki/Digital_object_identifier\" title=\"Digital object identifier\">doi</a>:<a class=\"external text\" href=\"//doi.org/10.1111%2Fcoin.12004\" rel=\"nofollow\">10.1111/coin.12004</a>.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Computational+Intelligence&amp;rft.atitle=Bridging+the+gap+between+distance+and+generalization&amp;rft.volume=30&amp;rft.issue=3&amp;rft.pages=473-513&amp;rft.date=2014&amp;rft_id=info%3Adoi%2F10.1111%2Fcoin.12004&amp;rft.aulast=Estruch&amp;rft.aufirst=V.&amp;rft.au=Ferri%2C+C.&amp;rft.au=Hernandez-Orallo%2C+J.&amp;rft.au=Ramirez-Quintana%2C+M.J.&amp;rft_id=https%3A%2F%2Fpdfs.semanticscholar.org%2F48f2%2F2821220555f8e327c2aa9614fb28c98f9542.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-28\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-28\">^</a></b></span> <span class=\"reference-text\">\n<cite class=\"citation journal\">Henderson, R.J.; Muggleton, S.H. (2012). <a class=\"external text\" href=\"http://ilp11.doc.ic.ac.uk/short_papers/ilp2011_submission_62.pdf\" rel=\"nofollow\">\"Automatic invention of functional abstractions\"</a> <span class=\"cs1-format\">(PDF)</span>. <i>Advances in Inductive Logic Programming</i>.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Advances+in+Inductive+Logic+Programming&amp;rft.atitle=Automatic+invention+of+functional+abstractions&amp;rft.date=2012&amp;rft.aulast=Henderson&amp;rft.aufirst=R.J.&amp;rft.au=Muggleton%2C+S.H.&amp;rft_id=http%3A%2F%2Filp11.doc.ic.ac.uk%2Fshort_papers%2Filp2011_submission_62.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-29\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-29\">^</a></b></span> <span class=\"reference-text\">\n<cite class=\"citation arxiv\">Irvin, H.; Stuhlmuller, A.; Goodman, N.D. (2011). \"Inducing probabilistic programs by Bayesian program merging\". <a href=\"/wiki/ArXiv\" title=\"ArXiv\">arXiv</a>:<span class=\"cs1-lock-free\" title=\"Freely accessible\"><a class=\"external text\" href=\"//arxiv.org/abs/1110.5667\" rel=\"nofollow\">1110.5667</a></span> [<a class=\"external text\" href=\"//arxiv.org/archive/cs.AI\" rel=\"nofollow\">cs.AI</a>].</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=preprint&amp;rft.jtitle=arXiv&amp;rft.atitle=Inducing+probabilistic+programs+by+Bayesian+program+merging&amp;rft.date=2011&amp;rft_id=info%3Aarxiv%2F1110.5667&amp;rft.aulast=Irvin&amp;rft.aufirst=H.&amp;rft.au=Stuhlmuller%2C+A.&amp;rft.au=Goodman%2C+N.D.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-30\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-30\">^</a></b></span> <span class=\"reference-text\">\n<cite class=\"citation journal\">Muggleton, S. (2000). <a class=\"external text\" href=\"https://ocs.aaai.org/Papers/Workshops/2000/WS-00-06/WS00-06-006.pdf\" rel=\"nofollow\">\"Learning stochastic logic programs\"</a> <span class=\"cs1-format\">(PDF)</span>. <i>Electron. Trans. Artif. Intell</i>. <b>4(B)</b>: 141–153.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Electron.+Trans.+Artif.+Intell.&amp;rft.atitle=Learning+stochastic+logic+programs&amp;rft.volume=4%28B%29&amp;rft.pages=141-153&amp;rft.date=2000&amp;rft.aulast=Muggleton&amp;rft.aufirst=S.&amp;rft_id=https%3A%2F%2Focs.aaai.org%2FPapers%2FWorkshops%2F2000%2FWS-00-06%2FWS00-06-006.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-31\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-31\">^</a></b></span> <span class=\"reference-text\">\n<cite class=\"citation book\">De Raedt, L.; Kersting, K. (2008). <i>Probabilistic inductive logic programming</i>. Springer.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Probabilistic+inductive+logic+programming&amp;rft.pub=Springer&amp;rft.date=2008&amp;rft.aulast=De+Raedt&amp;rft.aufirst=L.&amp;rft.au=Kersting%2C+K.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-32\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-32\">^</a></b></span> <span class=\"reference-text\">\n<cite class=\"citation arxiv\">Irvin, H.; Stuhlmuller, A.; Goodman, N.D. (2011). \"Inducing probabilistic programs by Bayesian program merging\". <a href=\"/wiki/ArXiv\" title=\"ArXiv\">arXiv</a>:<span class=\"cs1-lock-free\" title=\"Freely accessible\"><a class=\"external text\" href=\"//arxiv.org/abs/1110.5667\" rel=\"nofollow\">1110.5667</a></span> [<a class=\"external text\" href=\"//arxiv.org/archive/cs.AI\" rel=\"nofollow\">cs.AI</a>].</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=preprint&amp;rft.jtitle=arXiv&amp;rft.atitle=Inducing+probabilistic+programs+by+Bayesian+program+merging&amp;rft.date=2011&amp;rft_id=info%3Aarxiv%2F1110.5667&amp;rft.aulast=Irvin&amp;rft.aufirst=H.&amp;rft.au=Stuhlmuller%2C+A.&amp;rft.au=Goodman%2C+N.D.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-33\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-33\">^</a></b></span> <span class=\"reference-text\">\n<cite class=\"citation journal\">Stuhlmuller, A.; Goodman, N.D. (2012). <a class=\"external text\" href=\"https://pdfs.semanticscholar.org/7179/dc966bbfedeccd65fdb2f4b6f1e95f1cb073.pdf\" rel=\"nofollow\">\"Reasoning about reasoning by nested conditioning: Modeling theory of mind with probabilistic programs\"</a> <span class=\"cs1-format\">(PDF)</span>. <i>Cognitive Systems Research</i>.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Cognitive+Systems+Research&amp;rft.atitle=Reasoning+about+reasoning+by+nested+conditioning%3A+Modeling+theory+of+mind+with+probabilistic+programs&amp;rft.date=2012&amp;rft.aulast=Stuhlmuller&amp;rft.aufirst=A.&amp;rft.au=Goodman%2C+N.D.&amp;rft_id=https%3A%2F%2Fpdfs.semanticscholar.org%2F7179%2Fdc966bbfedeccd65fdb2f4b6f1e95f1cb073.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-34\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-34\">^</a></b></span> <span class=\"reference-text\">\n<cite class=\"citation book\">Lieberman, H.; Paternò, F.; Wulf, V. (2006). <i>End user development</i>. Springer.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=End+user+development&amp;rft.pub=Springer&amp;rft.date=2006&amp;rft.aulast=Lieberman&amp;rft.aufirst=H.&amp;rft.au=Patern%C3%B2%2C+F.&amp;rft.au=Wulf%2C+V.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-35\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-35\">^</a></b></span> <span class=\"reference-text\">\n<cite class=\"citation book\">Lieberman, H. (2001). <a class=\"external text\" href=\"https://books.google.com/books?id=wM2JYafw11gC\" rel=\"nofollow\"><i>Your wish is my command: Programming by example</i></a>. Morgan Kaufmann. <a href=\"/wiki/International_Standard_Book_Number\" title=\"International Standard Book Number\">ISBN</a> <a href=\"/wiki/Special:BookSources/9781558606883\" title=\"Special:BookSources/9781558606883\">9781558606883</a>.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Your+wish+is+my+command%3A+Programming+by+example&amp;rft.pub=Morgan+Kaufmann&amp;rft.date=2001&amp;rft.isbn=9781558606883&amp;rft.aulast=Lieberman&amp;rft.aufirst=H.&amp;rft_id=https%3A%2F%2Fbooks.google.com%2Fbooks%3Fid%3DwM2JYafw11gC&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-36\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-36\">^</a></b></span> <span class=\"reference-text\">\n<cite class=\"citation book\">Cypher, E.; Halbert, D.C. (1993). <a class=\"external text\" href=\"https://books.google.com/books?id=Ggzjo0-W1y0C\" rel=\"nofollow\"><i>Watch what I do: programming by demonstration</i></a>. <a href=\"/wiki/International_Standard_Book_Number\" title=\"International Standard Book Number\">ISBN</a> <a href=\"/wiki/Special:BookSources/9780262032131\" title=\"Special:BookSources/9780262032131\">9780262032131</a>.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Watch+what+I+do%3A+programming+by+demonstration&amp;rft.date=1993&amp;rft.isbn=9780262032131&amp;rft.aulast=Cypher&amp;rft.aufirst=E.&amp;rft.au=Halbert%2C+D.C.&amp;rft_id=https%3A%2F%2Fbooks.google.com%2Fbooks%3Fid%3DGgzjo0-W1y0C&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-37\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-37\">^</a></b></span> <span class=\"reference-text\">\n<cite class=\"citation journal\">Schmid, U.; Hofmann, M.; Kitzelmann, E. (2009). <a class=\"external text\" href=\"http://www.cogsys.wiai.uni-bamberg.de/publications/cognigor-final.pdf\" rel=\"nofollow\">\"Analytical inductive programming as a cognitive rule acquisition devise\"</a> <span class=\"cs1-format\">(PDF)</span>. <i>Proceedings of the Second Conference on Artificial General Intelligence</i>: 162–167.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Proceedings+of+the+Second+Conference+on+Artificial+General+Intelligence&amp;rft.atitle=Analytical+inductive+programming+as+a+cognitive+rule+acquisition+devise&amp;rft.pages=162-167&amp;rft.date=2009&amp;rft.aulast=Schmid&amp;rft.aufirst=U.&amp;rft.au=Hofmann%2C+M.&amp;rft.au=Kitzelmann%2C+E.&amp;rft_id=http%3A%2F%2Fwww.cogsys.wiai.uni-bamberg.de%2Fpublications%2Fcognigor-final.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-38\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-38\">^</a></b></span> <span class=\"reference-text\">\n<cite class=\"citation journal\">Crossley, N.; Kitzelmann, E.; Hofmann, M.; Schmid, U. (2009). \"Combining analytical and evolutionary inductive programming\". <i>Proceedings of the Second Conference on Artificial General Intelligence</i>: 19–24.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Proceedings+of+the+Second+Conference+on+Artificial+General+Intelligence&amp;rft.atitle=Combining+analytical+and+evolutionary+inductive+programming&amp;rft.pages=19-24&amp;rft.date=2009&amp;rft.aulast=Crossley&amp;rft.aufirst=N.&amp;rft.au=Kitzelmann%2C+E.&amp;rft.au=Hofmann%2C+M.&amp;rft.au=Schmid%2C+U.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-39\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-39\">^</a></b></span> <span class=\"reference-text\">\n<cite class=\"citation journal\">Hernandez-Orallo, J. (2000). \"Constructive reinforcement learning\". <i>International Journal of Intelligent Systems</i>. <b>15</b> (3): 241–264. <a href=\"/wiki/CiteSeerX\" title=\"CiteSeerX\">CiteSeerX</a> <span class=\"cs1-lock-free\" title=\"Freely accessible\"><a class=\"external text\" href=\"//citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.8877\" rel=\"nofollow\">10.1.1.34.8877</a></span>. <a href=\"/wiki/Digital_object_identifier\" title=\"Digital object identifier\">doi</a>:<a class=\"external text\" href=\"//doi.org/10.1002%2F%28sici%291098-111x%28200003%2915%3A3%3C241%3A%3Aaid-int6%3E3.0.co%3B2-z\" rel=\"nofollow\">10.1002/(sici)1098-111x(200003)15:3&lt;241::aid-int6&gt;3.0.co;2-z</a>.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=International+Journal+of+Intelligent+Systems&amp;rft.atitle=Constructive+reinforcement+learning&amp;rft.volume=15&amp;rft.issue=3&amp;rft.pages=241-264&amp;rft.date=2000&amp;rft_id=%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fsummary%3Fdoi%3D10.1.1.34.8877&amp;rft_id=info%3Adoi%2F10.1002%2F%28sici%291098-111x%28200003%2915%3A3%3C241%3A%3Aaid-int6%3E3.0.co%3B2-z&amp;rft.aulast=Hernandez-Orallo&amp;rft.aufirst=J.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-40\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-40\">^</a></b></span> <span class=\"reference-text\">\n<cite class=\"citation journal\">Kemp, C.; Goodman, N.; Tenenbaum, J.B. (2007). \"Learning and using relational theories\". <i>Advances in Neural Information Processing Systems</i>: 753–760.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Advances+in+Neural+Information+Processing+Systems&amp;rft.atitle=Learning+and+using+relational+theories&amp;rft.pages=753-760&amp;rft.date=2007&amp;rft.aulast=Kemp&amp;rft.aufirst=C.&amp;rft.au=Goodman%2C+N.&amp;rft.au=Tenenbaum%2C+J.B.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-41\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-41\">^</a></b></span> <span class=\"reference-text\">\n<cite class=\"citation journal\">Schmid, U.; Kitzelmann, E. (2011). \"Inductive rule learning on the knowledge level\". <i>Cognitive Systems Research</i>. <b>12</b> (3): 237–248. <a href=\"/wiki/Digital_object_identifier\" title=\"Digital object identifier\">doi</a>:<a class=\"external text\" href=\"//doi.org/10.1016%2Fj.cogsys.2010.12.002\" rel=\"nofollow\">10.1016/j.cogsys.2010.12.002</a>.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Cognitive+Systems+Research&amp;rft.atitle=Inductive+rule+learning+on+the+knowledge+level&amp;rft.volume=12&amp;rft.issue=3&amp;rft.pages=237-248&amp;rft.date=2011&amp;rft_id=info%3Adoi%2F10.1016%2Fj.cogsys.2010.12.002&amp;rft.aulast=Schmid&amp;rft.aufirst=U.&amp;rft.au=Kitzelmann%2C+E.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n<li id=\"cite_note-42\"><span class=\"mw-cite-backlink\"><b><a href=\"#cite_ref-42\">^</a></b></span> <span class=\"reference-text\">\n<cite class=\"citation journal\">Stuhlmuller, A.; Goodman, N.D. (2012). \"Reasoning about reasoning by nested conditioning: Modeling theory of mind with probabilistic programs\". <i>Cognitive Systems Research</i>.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Cognitive+Systems+Research&amp;rft.atitle=Reasoning+about+reasoning+by+nested+conditioning%3A+Modeling+theory+of+mind+with+probabilistic+programs&amp;rft.date=2012&amp;rft.aulast=Stuhlmuller&amp;rft.aufirst=A.&amp;rft.au=Goodman%2C+N.D.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></span>\n</li>\n</ol></div></div>\n<h2><span class=\"mw-headline\" id=\"Further_reading\">Further reading</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/w/index.php?title=Inductive_programming&amp;action=edit&amp;section=6\" title=\"Edit section: Further reading\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n<style data-mw-deduplicate=\"TemplateStyles:r853264625\">.mw-parser-output .refbegin{font-size:90%;margin-bottom:0.5em}.mw-parser-output .refbegin-hanging-indents>ul{list-style-type:none;margin-left:0}.mw-parser-output .refbegin-hanging-indents>ul>li,.mw-parser-output .refbegin-hanging-indents>dl>dd{margin-left:0;padding-left:3.2em;text-indent:-3.2em;list-style:none}.mw-parser-output .refbegin-100{font-size:100%}</style><div class=\"refbegin\" style=\"\">\n<ul><li><cite class=\"citation journal\">Flener, P.; Schmid, U. (2008). \"An introduction to inductive programming\". <i>Artificial Intelligence Review</i>. <b>29</b> (1): 45–62. <a href=\"/wiki/Digital_object_identifier\" title=\"Digital object identifier\">doi</a>:<a class=\"external text\" href=\"//doi.org/10.1007%2Fs10462-009-9108-7\" rel=\"nofollow\">10.1007/s10462-009-9108-7</a>.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Artificial+Intelligence+Review&amp;rft.atitle=An+introduction+to+inductive+programming&amp;rft.volume=29&amp;rft.issue=1&amp;rft.pages=45-62&amp;rft.date=2008&amp;rft_id=info%3Adoi%2F10.1007%2Fs10462-009-9108-7&amp;rft.aulast=Flener&amp;rft.aufirst=P.&amp;rft.au=Schmid%2C+U.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></li>\n<li><cite class=\"citation book\">Kitzelmann, E. (2010). <a class=\"external text\" href=\"http://emanuel.kitzelmann.org/documents/publications/Kitzelmann2010.pdf\" rel=\"nofollow\"><i>Inductive programming: A survey of program synthesis techniques</i></a> <span class=\"cs1-format\">(PDF)</span>. <i>Approaches and Applications of Inductive Programming</i>. Lecture Notes in Computer Science. <b>5812</b>. pp. 50–73. <a href=\"/wiki/CiteSeerX\" title=\"CiteSeerX\">CiteSeerX</a> <span class=\"cs1-lock-free\" title=\"Freely accessible\"><a class=\"external text\" href=\"//citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.180.1237\" rel=\"nofollow\">10.1.1.180.1237</a></span>. <a href=\"/wiki/Digital_object_identifier\" title=\"Digital object identifier\">doi</a>:<a class=\"external text\" href=\"//doi.org/10.1007%2F978-3-642-11931-6_3\" rel=\"nofollow\">10.1007/978-3-642-11931-6_3</a>. <a href=\"/wiki/International_Standard_Book_Number\" title=\"International Standard Book Number\">ISBN</a> <a href=\"/wiki/Special:BookSources/978-3-642-11930-9\" title=\"Special:BookSources/978-3-642-11930-9\">978-3-642-11930-9</a>.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Inductive+programming%3A+A+survey+of+program+synthesis+techniques&amp;rft.series=Lecture+Notes+in+Computer+Science&amp;rft.pages=50-73&amp;rft.date=2010&amp;rft_id=%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fsummary%3Fdoi%3D10.1.1.180.1237&amp;rft_id=info%3Adoi%2F10.1007%2F978-3-642-11931-6_3&amp;rft.isbn=978-3-642-11930-9&amp;rft.aulast=Kitzelmann&amp;rft.aufirst=E.&amp;rft_id=http%3A%2F%2Femanuel.kitzelmann.org%2Fdocuments%2Fpublications%2FKitzelmann2010.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></li>\n<li><cite class=\"citation journal\">Partridge, D. (1997). \"The case for inductive programming\". <i>Computer</i>. <b>30</b> (1): 36–41. <a href=\"/wiki/Digital_object_identifier\" title=\"Digital object identifier\">doi</a>:<a class=\"external text\" href=\"//doi.org/10.1109%2F2.562924\" rel=\"nofollow\">10.1109/2.562924</a>.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Computer&amp;rft.atitle=The+case+for+inductive+programming&amp;rft.volume=30&amp;rft.issue=1&amp;rft.pages=36-41&amp;rft.date=1997&amp;rft_id=info%3Adoi%2F10.1109%2F2.562924&amp;rft.aulast=Partridge&amp;rft.aufirst=D.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></li>\n<li><cite class=\"citation journal\">Flener, P.; Partridge, D. (2001). \"Inductive Programming\". <i>Automated Software Engineering</i>. <b>8</b> (2): 131–137. <a href=\"/wiki/Digital_object_identifier\" title=\"Digital object identifier\">doi</a>:<a class=\"external text\" href=\"//doi.org/10.1023%2Fa%3A1008797606116\" rel=\"nofollow\">10.1023/a:1008797606116</a>.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Automated+Software+Engineering&amp;rft.atitle=Inductive+Programming&amp;rft.volume=8&amp;rft.issue=2&amp;rft.pages=131-137&amp;rft.date=2001&amp;rft_id=info%3Adoi%2F10.1023%2Fa%3A1008797606116&amp;rft.aulast=Flener&amp;rft.aufirst=P.&amp;rft.au=Partridge%2C+D.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></li>\n<li><cite class=\"citation journal\">Hofmann, M.; Kitzelmann, E. (2009). <a class=\"external text\" href=\"http://www.atlantis-press.com/php/download_paper.php?id=1839\" rel=\"nofollow\">\"A unifying framework for analysis and evaluation of inductive programming systems\"</a>. <i>Proceedings of the Second Conference on Artificial General Intelligence</i>: 55–60.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Proceedings+of+the+Second+Conference+on+Artificial+General+Intelligence&amp;rft.atitle=A+unifying+framework+for+analysis+and+evaluation+of+inductive+programming+systems&amp;rft.pages=55-60&amp;rft.date=2009&amp;rft.aulast=Hofmann&amp;rft.aufirst=M.&amp;rft.au=Kitzelmann%2C+E.&amp;rft_id=http%3A%2F%2Fwww.atlantis-press.com%2Fphp%2Fdownload_paper.php%3Fid%3D1839&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></li>\n<li><cite class=\"citation journal\">Muggleton, S.; De Raedt, L. (1994). \"Inductive Logic Programming: Theory and methods\". <i>The Journal of Logic Programming</i>. 19-20: 629–679. <a href=\"/wiki/Digital_object_identifier\" title=\"Digital object identifier\">doi</a>:<a class=\"external text\" href=\"//doi.org/10.1016%2F0743-1066%2894%2990035-3\" rel=\"nofollow\">10.1016/0743-1066(94)90035-3</a>.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=The+Journal+of+Logic+Programming&amp;rft.atitle=Inductive+Logic+Programming%3A+Theory+and+methods&amp;rft.volume=19-20&amp;rft.pages=629-679&amp;rft.date=1994&amp;rft_id=info%3Adoi%2F10.1016%2F0743-1066%2894%2990035-3&amp;rft.aulast=Muggleton&amp;rft.aufirst=S.&amp;rft.au=De+Raedt%2C+L.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></li>\n<li><cite class=\"citation book\">Lavrac, N.; Dzeroski, S. (1994). <i>Inductive Logic Programming: Techniques and Applications</i>. New York: Ellis Horwood. <a href=\"/wiki/International_Standard_Book_Number\" title=\"International Standard Book Number\">ISBN</a> <a href=\"/wiki/Special:BookSources/978-0-13-457870-5\" title=\"Special:BookSources/978-0-13-457870-5\">978-0-13-457870-5</a>.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Inductive+Logic+Programming%3A+Techniques+and+Applications&amp;rft.place=New+York&amp;rft.pub=Ellis+Horwood&amp;rft.date=1994&amp;rft.isbn=978-0-13-457870-5&amp;rft.aulast=Lavrac&amp;rft.aufirst=N.&amp;rft.au=Dzeroski%2C+S.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/> <a class=\"external free\" href=\"https://web.archive.org/web/20040906084947/http://www-ai.ijs.si/SasoDzeroski/ILPBook/\" rel=\"nofollow\">https://web.archive.org/web/20040906084947/http://www-ai.ijs.si/SasoDzeroski/ILPBook/</a></li>\n<li><cite class=\"citation journal\">Muggleton, S.; De Raedt, Luc.; Poole, D.; Bratko, I.; Flach, P.; Inoue, K.; Srinivasan, A. (2012). \"ILP turns 20\". <i>Machine Learning</i>. <b>86</b> (1): 3–23. <a href=\"/wiki/Digital_object_identifier\" title=\"Digital object identifier\">doi</a>:<a class=\"external text\" href=\"//doi.org/10.1007%2Fs10994-011-5259-2\" rel=\"nofollow\">10.1007/s10994-011-5259-2</a>.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Machine+Learning&amp;rft.atitle=ILP+turns+20&amp;rft.volume=86&amp;rft.issue=1&amp;rft.pages=3-23&amp;rft.date=2012&amp;rft_id=info%3Adoi%2F10.1007%2Fs10994-011-5259-2&amp;rft.aulast=Muggleton&amp;rft.aufirst=S.&amp;rft.au=De+Raedt%2C+Luc.&amp;rft.au=Poole%2C+D.&amp;rft.au=Bratko%2C+I.&amp;rft.au=Flach%2C+P.&amp;rft.au=Inoue%2C+K.&amp;rft.au=Srinivasan%2C+A.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></li>\n<li><cite class=\"citation journal\">Galwani, S.; Hernandez-Orallo, J.; Kitzelmann, E.; Muggleton, S.H.; Schmid, U.; Zorn, B. (2015). <a class=\"external text\" href=\"http://cacm.acm.org/magazines/2015/11/193326-inductive-programming-meets-the-real-world/abstract\" rel=\"nofollow\">\"Inductive Programming Meets the Real World\"</a>. <i>Communications of the ACM</i>. <b>58</b> (11): 90–99. <a href=\"/wiki/CiteSeerX\" title=\"CiteSeerX\">CiteSeerX</a> <span class=\"cs1-lock-free\" title=\"Freely accessible\"><a class=\"external text\" href=\"//citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.696.3800\" rel=\"nofollow\">10.1.1.696.3800</a></span>. <a href=\"/wiki/Digital_object_identifier\" title=\"Digital object identifier\">doi</a>:<a class=\"external text\" href=\"//doi.org/10.1145%2F2736282\" rel=\"nofollow\">10.1145/2736282</a>.</cite><span class=\"Z3988\" title=\"ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Communications+of+the+ACM&amp;rft.atitle=Inductive+Programming+Meets+the+Real+World&amp;rft.volume=58&amp;rft.issue=11&amp;rft.pages=90-99&amp;rft.date=2015&amp;rft_id=%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fsummary%3Fdoi%3D10.1.1.696.3800&amp;rft_id=info%3Adoi%2F10.1145%2F2736282&amp;rft.aulast=Galwani&amp;rft.aufirst=S.&amp;rft.au=Hernandez-Orallo%2C+J.&amp;rft.au=Kitzelmann%2C+E.&amp;rft.au=Muggleton%2C+S.H.&amp;rft.au=Schmid%2C+U.&amp;rft.au=Zorn%2C+B.&amp;rft_id=http%3A%2F%2Fcacm.acm.org%2Fmagazines%2F2015%2F11%2F193326-inductive-programming-meets-the-real-world%2Fabstract&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AInductive+programming\"></span><link href=\"mw-data:TemplateStyles:r879151008\" rel=\"mw-deduplicated-inline-style\"/></li></ul>\n<h2><span class=\"mw-headline\" id=\"External_links\">External links</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/w/index.php?title=Inductive_programming&amp;action=edit&amp;section=7\" title=\"Edit section: External links\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h2>\n<ul><li><a class=\"external text\" href=\"http://www.inductive-programming.org/\" rel=\"nofollow\">Inductive Programming community page</a>, hosted by the University of Bamberg.</li></ul>\n</div>\n<!-- \nNewPP limit report\nParsed by mw1282\nCached time: 20190220063628\nCache expiry: 2073600\nDynamic content: false\nCPU time usage: 0.476 seconds\nReal time usage: 0.529 seconds\nPreprocessor visited node count: 2306/1000000\nPreprocessor generated node count: 0/1500000\nPost‐expand include size: 97450/2097152 bytes\nTemplate argument size: 213/2097152 bytes\nHighest expansion depth: 7/40\nExpensive parser function count: 3/500\nUnstrip recursion depth: 1/20\nUnstrip post‐expand size: 142031/5000000 bytes\nNumber of Wikibase entities loaded: 3/400\nLua time usage: 0.306/10.000 seconds\nLua memory usage: 4.01 MB/50 MB\n-->\n<!--\nTransclusion expansion time report (%,ms,calls,template)\n100.00%  455.906      1 -total\n 76.92%  350.663      1 Template:Reflist\n 53.52%  243.993     35 Template:Cite_journal\n 17.01%   77.568     13 Template:Cite_book\n  5.69%   25.963      1 Template:Programming_paradigms\n  5.10%   23.231      1 Template:Sidebar\n  4.10%   18.697      2 Template:Cite_arXiv\n  2.30%   10.500      1 Template:Citation\n  2.19%    9.980      1 Template:Refbegin\n  0.56%    2.570      1 Template:Main_other\n-->\n<!-- Saved in parser cache with key enwiki:pcache:idhash:41644056-0!canonical and timestamp 20190220063627 and revision id 884213955\n -->\n</div><noscript><img alt=\"\" height=\"1\" src=\"//en.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1\" style=\"border: none; position: absolute;\" title=\"\" width=\"1\"/></noscript></div> <div class=\"printfooter\">\n\t\t\t\t\t\tRetrieved from \"<a dir=\"ltr\" href=\"https://en.wikipedia.org/w/index.php?title=Inductive_programming&amp;oldid=884213955\">https://en.wikipedia.org/w/index.php?title=Inductive_programming&amp;oldid=884213955</a>\"\t\t\t\t\t</div>\n<div class=\"catlinks\" data-mw=\"interface\" id=\"catlinks\"><div class=\"mw-normal-catlinks\" id=\"mw-normal-catlinks\"><a href=\"/wiki/Help:Category\" title=\"Help:Category\">Categories</a>: <ul><li><a href=\"/wiki/Category:Programming_paradigms\" title=\"Category:Programming paradigms\">Programming paradigms</a></li><li><a href=\"/wiki/Category:Machine_learning\" title=\"Category:Machine learning\">Machine learning</a></li><li><a href=\"/wiki/Category:Logic_programming\" title=\"Category:Logic programming\">Logic programming</a></li><li><a href=\"/wiki/Category:Artificial_intelligence\" title=\"Category:Artificial intelligence\">Artificial intelligence</a></li></ul></div><div class=\"mw-hidden-catlinks mw-hidden-cats-hidden\" id=\"mw-hidden-catlinks\">Hidden categories: <ul><li><a href=\"/wiki/Category:CS1:_long_volume_value\" title=\"Category:CS1: long volume value\">CS1: long volume value</a></li></ul></div></div> <div class=\"visualClear\"></div>\n</div>\n</div>\n<div id=\"mw-navigation\">\n<h2>Navigation menu</h2>\n<div id=\"mw-head\">\n<div aria-labelledby=\"p-personal-label\" id=\"p-personal\" role=\"navigation\">\n<h3 id=\"p-personal-label\">Personal tools</h3>\n<ul>\n<li id=\"pt-anonuserpage\">Not logged in</li><li id=\"pt-anontalk\"><a accesskey=\"n\" href=\"/wiki/Special:MyTalk\" title=\"Discussion about edits from this IP address [n]\">Talk</a></li><li id=\"pt-anoncontribs\"><a accesskey=\"y\" href=\"/wiki/Special:MyContributions\" title=\"A list of edits made from this IP address [y]\">Contributions</a></li><li id=\"pt-createaccount\"><a href=\"/w/index.php?title=Special:CreateAccount&amp;returnto=Inductive+programming\" title=\"You are encouraged to create an account and log in; however, it is not mandatory\">Create account</a></li><li id=\"pt-login\"><a accesskey=\"o\" href=\"/w/index.php?title=Special:UserLogin&amp;returnto=Inductive+programming\" title=\"You're encouraged to log in; however, it's not mandatory. [o]\">Log in</a></li> </ul>\n</div>\n<div id=\"left-navigation\">\n<div aria-labelledby=\"p-namespaces-label\" class=\"vectorTabs\" id=\"p-namespaces\" role=\"navigation\">\n<h3 id=\"p-namespaces-label\">Namespaces</h3>\n<ul>\n<li class=\"selected\" id=\"ca-nstab-main\"><span><a accesskey=\"c\" href=\"/wiki/Inductive_programming\" title=\"View the content page [c]\">Article</a></span></li><li id=\"ca-talk\"><span><a accesskey=\"t\" href=\"/wiki/Talk:Inductive_programming\" rel=\"discussion\" title=\"Discussion about the content page [t]\">Talk</a></span></li> </ul>\n</div>\n<div aria-labelledby=\"p-variants-label\" class=\"vectorMenu emptyPortlet\" id=\"p-variants\" role=\"navigation\">\n<input aria-labelledby=\"p-variants-label\" class=\"vectorMenuCheckbox\" type=\"checkbox\"/>\n<h3 id=\"p-variants-label\">\n<span>Variants</span>\n</h3>\n<ul class=\"menu\">\n</ul>\n</div>\n</div>\n<div id=\"right-navigation\">\n<div aria-labelledby=\"p-views-label\" class=\"vectorTabs\" id=\"p-views\" role=\"navigation\">\n<h3 id=\"p-views-label\">Views</h3>\n<ul>\n<li class=\"collapsible selected\" id=\"ca-view\"><span><a href=\"/wiki/Inductive_programming\">Read</a></span></li><li class=\"collapsible\" id=\"ca-edit\"><span><a accesskey=\"e\" href=\"/w/index.php?title=Inductive_programming&amp;action=edit\" title=\"Edit this page [e]\">Edit</a></span></li><li class=\"collapsible\" id=\"ca-history\"><span><a accesskey=\"h\" href=\"/w/index.php?title=Inductive_programming&amp;action=history\" title=\"Past revisions of this page [h]\">View history</a></span></li> </ul>\n</div>\n<div aria-labelledby=\"p-cactions-label\" class=\"vectorMenu emptyPortlet\" id=\"p-cactions\" role=\"navigation\">\n<input aria-labelledby=\"p-cactions-label\" class=\"vectorMenuCheckbox\" type=\"checkbox\"/>\n<h3 id=\"p-cactions-label\"><span>More</span></h3>\n<ul class=\"menu\">\n</ul>\n</div>\n<div id=\"p-search\" role=\"search\">\n<h3>\n<label for=\"searchInput\">Search</label>\n</h3>\n<form action=\"/w/index.php\" id=\"searchform\">\n<div id=\"simpleSearch\">\n<input accesskey=\"f\" id=\"searchInput\" name=\"search\" placeholder=\"Search Wikipedia\" title=\"Search Wikipedia [f]\" type=\"search\"/><input name=\"title\" type=\"hidden\" value=\"Special:Search\"/><input class=\"searchButton mw-fallbackSearchButton\" id=\"mw-searchButton\" name=\"fulltext\" title=\"Search Wikipedia for this text\" type=\"submit\" value=\"Search\"/><input class=\"searchButton\" id=\"searchButton\" name=\"go\" title=\"Go to a page with this exact name if it exists\" type=\"submit\" value=\"Go\"/> </div>\n</form>\n</div>\n</div>\n</div>\n<div id=\"mw-panel\">\n<div id=\"p-logo\" role=\"banner\"><a class=\"mw-wiki-logo\" href=\"/wiki/Main_Page\" title=\"Visit the main page\"></a></div>\n<div aria-labelledby=\"p-navigation-label\" class=\"portal\" id=\"p-navigation\" role=\"navigation\">\n<h3 id=\"p-navigation-label\">Navigation</h3>\n<div class=\"body\">\n<ul>\n<li id=\"n-mainpage-description\"><a accesskey=\"z\" href=\"/wiki/Main_Page\" title=\"Visit the main page [z]\">Main page</a></li><li id=\"n-contents\"><a href=\"/wiki/Portal:Contents\" title=\"Guides to browsing Wikipedia\">Contents</a></li><li id=\"n-featuredcontent\"><a href=\"/wiki/Portal:Featured_content\" title=\"Featured content – the best of Wikipedia\">Featured content</a></li><li id=\"n-currentevents\"><a href=\"/wiki/Portal:Current_events\" title=\"Find background information on current events\">Current events</a></li><li id=\"n-randompage\"><a accesskey=\"x\" href=\"/wiki/Special:Random\" title=\"Load a random article [x]\">Random article</a></li><li id=\"n-sitesupport\"><a href=\"https://donate.wikimedia.org/wiki/Special:FundraiserRedirector?utm_source=donate&amp;utm_medium=sidebar&amp;utm_campaign=C13_en.wikipedia.org&amp;uselang=en\" title=\"Support us\">Donate to Wikipedia</a></li><li id=\"n-shoplink\"><a href=\"//shop.wikimedia.org\" title=\"Visit the Wikipedia store\">Wikipedia store</a></li> </ul>\n</div>\n</div>\n<div aria-labelledby=\"p-interaction-label\" class=\"portal\" id=\"p-interaction\" role=\"navigation\">\n<h3 id=\"p-interaction-label\">Interaction</h3>\n<div class=\"body\">\n<ul>\n<li id=\"n-help\"><a href=\"/wiki/Help:Contents\" title=\"Guidance on how to use and edit Wikipedia\">Help</a></li><li id=\"n-aboutsite\"><a href=\"/wiki/Wikipedia:About\" title=\"Find out about Wikipedia\">About Wikipedia</a></li><li id=\"n-portal\"><a href=\"/wiki/Wikipedia:Community_portal\" title=\"About the project, what you can do, where to find things\">Community portal</a></li><li id=\"n-recentchanges\"><a accesskey=\"r\" href=\"/wiki/Special:RecentChanges\" title=\"A list of recent changes in the wiki [r]\">Recent changes</a></li><li id=\"n-contactpage\"><a href=\"//en.wikipedia.org/wiki/Wikipedia:Contact_us\" title=\"How to contact Wikipedia\">Contact page</a></li> </ul>\n</div>\n</div>\n<div aria-labelledby=\"p-tb-label\" class=\"portal\" id=\"p-tb\" role=\"navigation\">\n<h3 id=\"p-tb-label\">Tools</h3>\n<div class=\"body\">\n<ul>\n<li id=\"t-whatlinkshere\"><a accesskey=\"j\" href=\"/wiki/Special:WhatLinksHere/Inductive_programming\" title=\"List of all English Wikipedia pages containing links to this page [j]\">What links here</a></li><li id=\"t-recentchangeslinked\"><a accesskey=\"k\" href=\"/wiki/Special:RecentChangesLinked/Inductive_programming\" rel=\"nofollow\" title=\"Recent changes in pages linked from this page [k]\">Related changes</a></li><li id=\"t-upload\"><a accesskey=\"u\" href=\"/wiki/Wikipedia:File_Upload_Wizard\" title=\"Upload files [u]\">Upload file</a></li><li id=\"t-specialpages\"><a accesskey=\"q\" href=\"/wiki/Special:SpecialPages\" title=\"A list of all special pages [q]\">Special pages</a></li><li id=\"t-permalink\"><a href=\"/w/index.php?title=Inductive_programming&amp;oldid=884213955\" title=\"Permanent link to this revision of the page\">Permanent link</a></li><li id=\"t-info\"><a href=\"/w/index.php?title=Inductive_programming&amp;action=info\" title=\"More information about this page\">Page information</a></li><li id=\"t-wikibase\"><a accesskey=\"g\" href=\"https://www.wikidata.org/wiki/Special:EntityPage/Q15712089\" title=\"Link to connected data repository item [g]\">Wikidata item</a></li><li id=\"t-cite\"><a href=\"/w/index.php?title=Special:CiteThisPage&amp;page=Inductive_programming&amp;id=884213955\" title=\"Information on how to cite this page\">Cite this page</a></li> </ul>\n</div>\n</div>\n<div aria-labelledby=\"p-coll-print_export-label\" class=\"portal\" id=\"p-coll-print_export\" role=\"navigation\">\n<h3 id=\"p-coll-print_export-label\">Print/export</h3>\n<div class=\"body\">\n<ul>\n<li id=\"coll-create_a_book\"><a href=\"/w/index.php?title=Special:Book&amp;bookcmd=book_creator&amp;referer=Inductive+programming\">Create a book</a></li><li id=\"coll-download-as-rdf2latex\"><a href=\"/w/index.php?title=Special:ElectronPdf&amp;page=Inductive+programming&amp;action=show-download-screen\">Download as PDF</a></li><li id=\"t-print\"><a accesskey=\"p\" href=\"/w/index.php?title=Inductive_programming&amp;printable=yes\" title=\"Printable version of this page [p]\">Printable version</a></li> </ul>\n</div>\n</div>\n<div aria-labelledby=\"p-lang-label\" class=\"portal\" id=\"p-lang\" role=\"navigation\">\n<h3 id=\"p-lang-label\">Languages</h3>\n<div class=\"body\">\n<ul>\n<li class=\"interlanguage-link interwiki-ja\"><a class=\"interlanguage-link-target\" href=\"https://ja.wikipedia.org/wiki/%E5%B8%B0%E7%B4%8D%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0\" hreflang=\"ja\" lang=\"ja\" title=\"帰納プログラミング – Japanese\">日本語</a></li><li class=\"interlanguage-link interwiki-sr\"><a class=\"interlanguage-link-target\" href=\"https://sr.wikipedia.org/wiki/%D0%98%D0%BD%D0%B4%D1%83%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%BE_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%B8%D1%80%D0%B0%D1%9A%D0%B5\" hreflang=\"sr\" lang=\"sr\" title=\"Индуктивно програмирање – Serbian\">Српски / srpski</a></li> </ul>\n<div class=\"after-portlet after-portlet-lang\"><span class=\"wb-langlinks-edit wb-langlinks-link\"><a class=\"wbc-editpage\" href=\"https://www.wikidata.org/wiki/Special:EntityPage/Q15712089#sitelinks-wikipedia\" title=\"Edit interlanguage links\">Edit links</a></span></div> </div>\n</div>\n</div>\n</div>\n<div id=\"footer\" role=\"contentinfo\">\n<ul id=\"footer-info\">\n<li id=\"footer-info-lastmod\"> This page was last edited on 20 February 2019, at 06:36<span class=\"anonymous-show\"> (UTC)</span>.</li>\n<li id=\"footer-info-copyright\">Text is available under the <a href=\"//en.wikipedia.org/wiki/Wikipedia:Text_of_Creative_Commons_Attribution-ShareAlike_3.0_Unported_License\" rel=\"license\">Creative Commons Attribution-ShareAlike License</a><a href=\"//creativecommons.org/licenses/by-sa/3.0/\" rel=\"license\" style=\"display:none;\"></a>;\nadditional terms may apply.  By using this site, you agree to the <a href=\"//foundation.wikimedia.org/wiki/Terms_of_Use\">Terms of Use</a> and <a href=\"//foundation.wikimedia.org/wiki/Privacy_policy\">Privacy Policy</a>. Wikipedia® is a registered trademark of the <a href=\"//www.wikimediafoundation.org/\">Wikimedia Foundation, Inc.</a>, a non-profit organization.</li>\n</ul>\n<ul id=\"footer-places\">\n<li id=\"footer-places-privacy\"><a class=\"extiw\" href=\"https://foundation.wikimedia.org/wiki/Privacy_policy\" title=\"wmf:Privacy policy\">Privacy policy</a></li>\n<li id=\"footer-places-about\"><a href=\"/wiki/Wikipedia:About\" title=\"Wikipedia:About\">About Wikipedia</a></li>\n<li id=\"footer-places-disclaimer\"><a href=\"/wiki/Wikipedia:General_disclaimer\" title=\"Wikipedia:General disclaimer\">Disclaimers</a></li>\n<li id=\"footer-places-contact\"><a href=\"//en.wikipedia.org/wiki/Wikipedia:Contact_us\">Contact Wikipedia</a></li>\n<li id=\"footer-places-developers\"><a href=\"https://www.mediawiki.org/wiki/Special:MyLanguage/How_to_contribute\">Developers</a></li>\n<li id=\"footer-places-cookiestatement\"><a href=\"https://foundation.wikimedia.org/wiki/Cookie_statement\">Cookie statement</a></li>\n<li id=\"footer-places-mobileview\"><a class=\"noprint stopMobileRedirectToggle\" href=\"//en.m.wikipedia.org/w/index.php?title=Inductive_programming&amp;mobileaction=toggle_view_mobile\">Mobile view</a></li>\n</ul>\n<ul class=\"noprint\" id=\"footer-icons\">\n<li id=\"footer-copyrightico\">\n<a href=\"https://wikimediafoundation.org/\"><img alt=\"Wikimedia Foundation\" height=\"31\" src=\"/static/images/wikimedia-button.png\" srcset=\"/static/images/wikimedia-button-1.5x.png 1.5x, /static/images/wikimedia-button-2x.png 2x\" width=\"88\"/></a> </li>\n<li id=\"footer-poweredbyico\">\n<a href=\"//www.mediawiki.org/\"><img alt=\"Powered by MediaWiki\" height=\"31\" src=\"/static/images/poweredby_mediawiki_88x31.png\" srcset=\"/static/images/poweredby_mediawiki_132x47.png 1.5x, /static/images/poweredby_mediawiki_176x62.png 2x\" width=\"88\"/></a> </li>\n</ul>\n<div style=\"clear: both;\"></div>\n</div>\n<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({\"wgPageParseReport\":{\"limitreport\":{\"cputime\":\"0.476\",\"walltime\":\"0.529\",\"ppvisitednodes\":{\"value\":2306,\"limit\":1000000},\"ppgeneratednodes\":{\"value\":0,\"limit\":1500000},\"postexpandincludesize\":{\"value\":97450,\"limit\":2097152},\"templateargumentsize\":{\"value\":213,\"limit\":2097152},\"expansiondepth\":{\"value\":7,\"limit\":40},\"expensivefunctioncount\":{\"value\":3,\"limit\":500},\"unstrip-depth\":{\"value\":1,\"limit\":20},\"unstrip-size\":{\"value\":142031,\"limit\":5000000},\"entityaccesscount\":{\"value\":3,\"limit\":400},\"timingprofile\":[\"100.00%  455.906      1 -total\",\" 76.92%  350.663      1 Template:Reflist\",\" 53.52%  243.993     35 Template:Cite_journal\",\" 17.01%   77.568     13 Template:Cite_book\",\"  5.69%   25.963      1 Template:Programming_paradigms\",\"  5.10%   23.231      1 Template:Sidebar\",\"  4.10%   18.697      2 Template:Cite_arXiv\",\"  2.30%   10.500      1 Template:Citation\",\"  2.19%    9.980      1 Template:Refbegin\",\"  0.56%    2.570      1 Template:Main_other\"]},\"scribunto\":{\"limitreport-timeusage\":{\"value\":\"0.306\",\"limit\":\"10.000\"},\"limitreport-memusage\":{\"value\":4209010,\"limit\":52428800}},\"cachereport\":{\"origin\":\"mw1282\",\"timestamp\":\"20190220063628\",\"ttl\":2073600,\"transientcontent\":false}}});});</script>\n<script type=\"application/ld+json\">{\"@context\":\"https:\\/\\/schema.org\",\"@type\":\"Article\",\"name\":\"Inductive programming\",\"url\":\"https:\\/\\/en.wikipedia.org\\/wiki\\/Inductive_programming\",\"sameAs\":\"http:\\/\\/www.wikidata.org\\/entity\\/Q15712089\",\"mainEntity\":\"http:\\/\\/www.wikidata.org\\/entity\\/Q15712089\",\"author\":{\"@type\":\"Organization\",\"name\":\"Contributors to Wikimedia projects\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Wikimedia Foundation, Inc.\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\/\\/www.wikimedia.org\\/static\\/images\\/wmf-hor-googpub.png\"}},\"datePublished\":\"2014-01-14T23:05:45Z\",\"dateModified\":\"2019-02-20T06:36:27Z\",\"headline\":\"programming paradigm\"}</script>\n<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({\"wgBackendResponseTime\":92,\"wgHostname\":\"mw1321\"});});</script>\n</body>\n</html>\n",
  "table_of_contents": [
    "1 Definition",
    "2 History",
    "3 Application areas",
    "4 See also",
    "5 References",
    "6 Further reading",
    "7 External links"
  ],
  "graphics": [],
  "paragraphs": [
    {
      "title": "",
      "text": "Inductive programming (IP) is a special area of automatic programming, covering research from artificial intelligence and programming, which addresses learning of typically declarative (logic or functional) and often recursive programs from incomplete specifications, such as input/output examples or constraints.\n\nDepending on the programming language used, there are several kinds of inductive programming. Inductive functional programming, which uses functional programming languages such as Lisp or Haskell, and most especially inductive logic programming, which uses logic programming languages such as Prolog and other logical representations  such as description logics, have been more prominent, but other (programming) language paradigms have also been used, such as constraint programming or probabilistic programming.\n\n"
    },
    {
      "title": "Definition",
      "text": "Inductive programming incorporates all approaches which are concerned with learning programs or algorithms from incomplete (formal) specifications. Possible inputs in an IP system are a set of training inputs and corresponding outputs or an output evaluation function, describing the desired behavior of the intended program, traces or action sequences which describe the process of calculating specific outputs, constraints for the program to be induced concerning its time efficiency or its complexity, various kinds of background knowledge such as standard data types, predefined functions to be used, program schemes or templates describing the data flow of the intended program, heuristics for guiding the search for a solution or other biases.\n\nOutput of an IP system is a program in some arbitrary programming language containing conditionals and loop or recursive control structures, or any other kind of Turing-complete representation language.\n\nIn many applications the output program must be correct with respect to the examples and partial specification,  and this leads to the consideration of inductive programming as a special area inside automatic programming or program synthesis,[1][2] usually opposed to 'deductive' program synthesis,[3][4][5] where the specification is usually complete.\n\nIn other cases, inductive programming is seen as a more general area where any declarative programming or representation language can be used and we may even have some degree of error in the examples, as in general machine learning, the more specific area of structure mining or the area of symbolic artificial intelligence. A distinctive feature is the number of examples or partial specification needed. Typically, inductive programming techniques can learn from just a few examples.\n\nThe diversity of inductive programming usually comes from the applications and the languages that are used: apart from logic programming and functional programming, other programming paradigms and representation languages have been used or suggested in inductive programming, such as functional logic programming, constraint programming, probabilistic programming, abductive logic programming, modal logic, action languages, agent languages and many types of imperative languages.\n\n"
    },
    {
      "title": "History",
      "text": "Research on the inductive synthesis of recursive functional programs started in the early 1970s and was brought onto firm theoretical foundations with the seminal THESIS system of Summers[6] and work of Biermann.[7]\nThese approaches were split into two phases: first, input-output examples are transformed into non-recursive programs (traces) using a small set of basic operators; second, regularities in the traces are searched for and used to fold them into a recursive program.  The main results until the mid 1980s are surveyed by Smith.[8] Due to limited progress with respect to the range of programs that could be synthesized, research activities decreased significantly in the next decade.\n\nThe advent of logic programming brought a new elan but also a new direction in the early 1980s, especially due to the MIS system of Shapiro[9] eventually spawning the new field of inductive logic programming (ILP).[10] The early works of Plotkin,[11][12] and his \"relative least general generalization (rlgg)\", had an enormous impact in inductive logic programming. Most of ILP work addresses a wider class of problems, as the focus is not only on recursive logic programs but on machine learning of symbolic hypotheses from logical representations. However, there were some encouraging results on learning recursive Prolog programs such as quicksort from examples together with suitable background knowledge, for example with GOLEM.[13] But again, after initial success, the community got disappointed by limited progress about the induction of recursive programs[14][15][16] with ILP less and less focusing on recursive programs and leaning more and more towards a machine learning setting with applications in relational data mining and knowledge discovery.[17]\n\nIn parallel to work in ILP, Koza[18] proposed genetic programming in the early 1990s as a generate-and-test based approach to learning programs. The idea of genetic programming was further developed into the inductive programming system ADATE[19] and the systematic-search-based system MagicHaskeller.[20] Here again, functional programs are learned from sets of positive examples together with an output evaluation (fitness) function which specifies the desired input/output behavior of the program to be learned.\n\nThe early work in grammar induction (also known as grammatical inference) is related to inductive programming, as rewriting systems or logic programs can be used to represent production rules. In fact, early works in inductive inference considered grammar induction and Lisp program inference as basically the same problem.[21] The results in terms of learnability were related to classical concepts, such as identification-in-the-limit, as introduced in the seminal work of Gold.[22] More recently, the language learning problem was addressed by the inductive programming community.[23][24]\n\nIn the recent years, the classical approaches have been resumed and advanced with great success. Therefore, the synthesis problem has been reformulated on the background of constructor-based term rewriting systems taking into account modern techniques of functional programming, as well as moderate use of search-based strategies and usage of background knowledge as well as automatic invention of subprograms. Many new and successful applications have recently appeared beyond program synthesis, most especially in the area of data manipulation, programming by example and cognitive modelling (see below).\n\nOther ideas have also been explored with the common characteristic of using declarative languages for the representation of hypotheses. For instance, the use of higher-order features, schemes or structured distances have been advocated for a better handling of recursive data types and structures;[25][26][27] abstraction has also been explored as a more powerful approach to cumulative learning and function invention.[28][29]\n\nOne powerful paradigm that has been recently used for the representation of hypotheses in inductive programming (generally in the form of generative models) is probabilistic programming (and related paradigms, such as stochastic logic programs and Bayesian logic programming).[30][31][32][33]\n\n"
    },
    {
      "title": "Application areas",
      "text": "The first workshop on Approaches and Applications of Inductive Programming (AAIP)  held in conjunction with ICML 2005 identified all applications where \"learning of programs or recursive rules are called for, [...] first in the domain of software engineering where structural learning, software assistants and software agents can help to relieve programmers from routine tasks, give programming support for end users, or support of novice programmers and programming tutor systems. Further areas of application are language learning, learning recursive control rules for AI-planning, learning recursive concepts in web-mining or for data-format transformations\".\n\nSince then, these and many other areas have shown to be successful application niches for inductive programming, such as end-user programming,[34] the related areas of programming by example[35] and programming by demonstration,[36] and intelligent tutoring systems.\n\nOther areas where inductive inference has been recently applied are knowledge acquisition,[37] artificial general intelligence,[38] reinforcement learning and theory evaluation,[39][40] and cognitive science in general.[41][42] There may also be prospective applications in intelligent agents, games, robotics, personalisation, ambient intelligence and human interfaces.\n\n"
    }
  ],
  "links": []
}